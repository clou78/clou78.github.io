<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Commander - Browser Tank Battle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e; 
            color: #fff; 
            overflow: hidden;
            user-select: none;
        }
        #game-container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; }
        
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000;
        }
        #loading-screen h1 { font-size: 3em; color: #f39c12; text-shadow: 0 0 20px rgba(243,156,18,0.5); margin-bottom: 30px; }
        .loading-bar { width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; }
        .loading-progress { height: 100%; background: linear-gradient(90deg, #f39c12, #e74c3c); width: 0%; transition: width 0.3s; }
        #loading-text { margin-top: 15px; color: #888; }
        
        #main-menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; z-index: 900;
        }
        .menu-content {
            position: absolute; left: 50px; top: 50%; transform: translateY(-50%);
        }
        .menu-title { font-size: 4em; color: #f39c12; text-shadow: 0 0 30px rgba(243,156,18,0.6); margin-bottom: 40px; }
        .menu-subtitle { color: #888; font-size: 1.2em; margin-bottom: 40px; }
        .menu-btn {
            display: block; padding: 15px 40px; margin: 10px 0; font-size: 1.2em;
            background: linear-gradient(135deg, #2d3436 0%, #1e272e 100%);
            border: 2px solid #f39c12; color: #fff; cursor: pointer;
            transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;
            width: 280px; text-align: left;
        }
        .menu-btn:hover { background: #f39c12; color: #000; transform: translateX(10px); }
        
        #tank-select {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; z-index: 950;
            overflow-y: auto;
        }
        .tank-grid {
            display: flex; gap: 15px; justify-content: center; align-items: center;
            flex-wrap: wrap; padding: 20px 50px;
        }
        .tank-card {
            width: 180px; padding: 15px; background: linear-gradient(135deg, #2d3436, #1e272e);
            border: 2px solid #444; border-radius: 10px; cursor: pointer; transition: all 0.3s;
            text-align: center;
        }
        .tank-card:hover, .tank-card.selected { border-color: #f39c12; transform: scale(1.05); }
        .tank-card h3 { color: #f39c12; margin-bottom: 8px; font-size: 1em; }
        .tank-card .nation { color: #888; font-size: 0.8em; margin-bottom: 10px; }
        .tank-stats { text-align: left; font-size: 0.75em; }
        .tank-stats div { display: flex; justify-content: space-between; margin: 3px 0; align-items: center; }
        .stat-bar { width: 50px; height: 6px; background: #333; border-radius: 3px; overflow: hidden; }
        .stat-fill { height: 100%; background: #f39c12; }
        
        #hud { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 100; }
        
        .hud-top {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; background: linear-gradient(180deg, rgba(0,0,0,0.7), transparent);
        }
        .team-score { display: flex; align-items: center; gap: 20px; }
        .score-box { padding: 8px 25px; font-size: 1.5em; font-weight: bold; border-radius: 5px; }
        .score-red { background: rgba(231,76,60,0.8); }
        .score-blue { background: rgba(52,152,219,0.8); }
        .match-timer { font-size: 2em; font-weight: bold; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        
        .minimap {
            position: absolute; left: 20px; bottom: 20px;
            width: 180px; height: 180px; background: rgba(0,0,0,0.7);
            border: 2px solid #444; border-radius: 5px; overflow: hidden;
        }
        .minimap-canvas { width: 100%; height: 100%; }
        
        .crosshair {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 80px; height: 80px; pointer-events: none;
        }
        .crosshair-line { position: absolute; background: rgba(255,255,255,0.7); }
        .crosshair-line.top { width: 2px; height: 15px; left: 39px; top: 10px; }
        .crosshair-line.bottom { width: 2px; height: 15px; left: 39px; bottom: 10px; }
        .crosshair-line.left { width: 15px; height: 2px; top: 39px; left: 10px; }
        .crosshair-line.right { width: 15px; height: 2px; top: 39px; right: 10px; }
        .crosshair-dot { 
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; background: #f39c12; border-radius: 50%;
        }
        
        .hud-bottom {
            position: absolute; bottom: 0; left: 0; right: 0;
            display: flex; justify-content: space-between; align-items: flex-end;
            padding: 20px; padding-left: 220px;
        }
        
        .player-tank-info {
            background: rgba(0,0,0,0.7); padding: 15px 20px; border-radius: 5px;
            border-top: 3px solid #3498db;
        }
        .player-tank-name { color: #3498db; font-weight: bold; margin-bottom: 8px; }
        .player-hp-bar { width: 220px; height: 18px; background: #333; border-radius: 3px; overflow: hidden; margin-bottom: 8px; position: relative; }
        .player-hp-fill { height: 100%; background: linear-gradient(90deg, #27ae60, #2ecc71); transition: width 0.3s; }
        .player-hp-text { position: absolute; width: 100%; text-align: center; top: 0; line-height: 18px; font-weight: bold; text-shadow: 1px 1px 2px #000; font-size: 0.85em; }
        
        .ammo-panel { display: flex; gap: 8px; margin-top: 8px; }
        .ammo-type {
            padding: 6px 12px; background: #333; border: 2px solid #555;
            border-radius: 5px; cursor: pointer; pointer-events: auto; font-size: 0.9em;
        }
        .ammo-type.selected { border-color: #f39c12; background: rgba(243,156,18,0.2); }
        .ammo-type .key { color: #f39c12; font-weight: bold; }
        .ammo-count { font-size: 0.85em; color: #888; }
        
        .reload-bar { width: 220px; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 8px; }
        .reload-fill { height: 100%; background: #f39c12; width: 100%; transition: width 0.1s linear; }
        
        .damage-indicator {
            position: absolute; left: 50%; top: 30%;
            transform: translateX(-50%); color: #e74c3c;
            font-size: 2em; font-weight: bold; animation: damageFloat 1s forwards;
            text-shadow: 0 0 10px rgba(231,76,60,0.8);
        }
        @keyframes damageFloat {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
        }
        
        .hit-marker {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            font-size: 3em; color: #f39c12; opacity: 0; pointer-events: none;
        }
        .hit-marker.show { animation: hitPulse 0.3s forwards; }
        @keyframes hitPulse {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        .kill-feed {
            position: absolute; top: 80px; right: 20px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .kill-entry {
            background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 3px;
            font-size: 0.9em; animation: killFade 4s forwards;
        }
        @keyframes killFade { 0%, 80% { opacity: 1; } 100% { opacity: 0; } }
        .kill-entry .killer { color: #3498db; }
        .kill-entry .victim { color: #e74c3c; }
        
        #settings-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; max-height: 80vh; background: linear-gradient(135deg, #1e272e, #2d3436);
            border: 2px solid #f39c12; border-radius: 10px; display: none; z-index: 1000;
            overflow: hidden;
        }
        .settings-header {
            padding: 15px 20px; background: rgba(0,0,0,0.3);
            display: flex; justify-content: space-between; align-items: center;
        }
        .settings-header h2 { color: #f39c12; }
        .close-btn { 
            background: none; border: none; color: #fff; font-size: 1.5em; 
            cursor: pointer; padding: 5px 10px;
        }
        .close-btn:hover { color: #e74c3c; }
        
        .settings-tabs { display: flex; background: rgba(0,0,0,0.2); }
        .settings-tab {
            flex: 1; padding: 12px; text-align: center; cursor: pointer;
            border-bottom: 3px solid transparent; transition: all 0.3s; font-size: 0.9em;
        }
        .settings-tab:hover { background: rgba(255,255,255,0.05); }
        .settings-tab.active { border-bottom-color: #f39c12; background: rgba(243,156,18,0.1); }
        
        .settings-content { padding: 20px; max-height: 350px; overflow-y: auto; }
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 0; border-bottom: 1px solid #333;
        }
        .setting-row:last-child { border-bottom: none; }
        
        input[type="range"] {
            width: 150px; height: 6px; -webkit-appearance: none;
            background: #333; border-radius: 3px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #f39c12; border-radius: 50%; cursor: pointer;
        }
        
        select {
            padding: 6px 12px; background: #333; border: 1px solid #555;
            color: #fff; border-radius: 5px; cursor: pointer;
        }
        
        .toggle {
            width: 44px; height: 22px; background: #333; border-radius: 11px;
            position: relative; cursor: pointer; transition: background 0.3s;
        }
        .toggle.active { background: #f39c12; }
        .toggle::after {
            content: ''; position: absolute; width: 18px; height: 18px;
            background: #fff; border-radius: 50%; top: 2px; left: 2px;
            transition: transform 0.3s;
        }
        .toggle.active::after { transform: translateX(22px); }
        
        #game-over {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; z-index: 800;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #game-over h1 { font-size: 4em; margin-bottom: 20px; }
        #game-over.victory h1 { color: #27ae60; }
        #game-over.defeat h1 { color: #e74c3c; }
        .game-stats { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 10px; margin: 20px 0; }
        .stat-row { display: flex; justify-content: space-between; gap: 50px; margin: 10px 0; }
        .stat-value { color: #f39c12; font-weight: bold; }
        
        .notification {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 15px 30px; border-radius: 5px;
            border: 1px solid #f39c12; z-index: 2000; animation: notifySlide 3s forwards;
        }
        @keyframes notifySlide {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10%, 90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }
        
        .map-select { margin-top: 20px; text-align: center; }
        .map-grid { display: flex; gap: 15px; margin-top: 15px; justify-content: center; flex-wrap: wrap; }
        .map-card {
            width: 140px; height: 90px; border: 2px solid #444;
            border-radius: 5px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; text-align: center; transition: all 0.3s;
            flex-direction: column; padding: 10px;
        }
        .map-card:hover, .map-card.selected { border-color: #f39c12; transform: scale(1.05); }
        .map-card h4 { color: #fff; font-size: 0.9em; }
        .map-card p { color: #888; font-size: 0.7em; margin-top: 5px; }
        .map-card.winter { background: linear-gradient(135deg, #a8d8ea, #5b8fb9); }
        .map-card.field { background: linear-gradient(135deg, #4a5d23, #2d4a0f); }
        .map-card.urban { background: linear-gradient(135deg, #555, #333); }
        .map-card.desert { background: linear-gradient(135deg, #c2a878, #8b7355); }
        
        #pause-menu {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); padding: 40px; border-radius: 10px;
            border: 2px solid #f39c12; display: none; z-index: 1100; text-align: center;
        }
        #pause-menu h2 { color: #f39c12; margin-bottom: 30px; }
        #pause-menu .menu-btn { margin: 10px auto; }
        
        .speed-indicator {
            position: absolute; right: 20px; bottom: 100px;
            background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 5px;
            text-align: center;
        }
        .speed-value { font-size: 1.5em; color: #f39c12; font-weight: bold; }
        .speed-label { font-size: 0.8em; color: #888; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="loading-screen">
        <h1>‚öîÔ∏è TANK COMMANDER ‚öîÔ∏è</h1>
        <div class="loading-bar"><div class="loading-progress" id="load-progress"></div></div>
        <p id="loading-text">Initializing engine...</p>
    </div>
    
    <div id="main-menu">
        <div class="menu-content">
            <h1 class="menu-title">TANK COMMANDER</h1>
            <p class="menu-subtitle">Armored Warfare Simulation</p>
            <button class="menu-btn" onclick="showTankSelect()">‚ñ∂ PLAY BATTLE</button>
            <button class="menu-btn" onclick="showSettings()">‚öôÔ∏è SETTINGS</button>
        </div>
    </div>
    
    <div id="tank-select">
        <button class="close-btn" style="position:absolute;top:20px;right:20px;pointer-events:auto;z-index:10;" onclick="hideTankSelect()">‚úï</button>
        <h2 style="text-align:center;padding:20px;color:#f39c12;font-size:1.5em;">SELECT YOUR TANK</h2>
        <div class="tank-grid" id="tank-grid"></div>
        <div class="map-select">
            <h3 style="color:#f39c12;">SELECT MAP</h3>
            <div class="map-grid" id="map-grid"></div>
        </div>
        <div style="text-align:center;margin:30px 0;">
            <button class="menu-btn" style="margin:0 auto;display:inline-block;width:auto;padding:15px 60px;" onclick="startBattle()">‚öîÔ∏è START BATTLE</button>
        </div>
    </div>
    
    <div id="hud">
        <div class="hud-top">
            <div class="team-score">
                <div class="score-box score-blue" id="blue-score">7</div>
                <span style="color:#888;">vs</span>
                <div class="score-box score-red" id="red-score">7</div>
            </div>
            <div class="match-timer" id="match-timer">5:00</div>
            <div style="width:150px;"></div>
        </div>
        
        <div class="minimap">
            <canvas class="minimap-canvas" id="minimap-canvas" width="180" height="180"></canvas>
        </div>
        
        <div class="crosshair">
            <div class="crosshair-line top"></div>
            <div class="crosshair-line bottom"></div>
            <div class="crosshair-line left"></div>
            <div class="crosshair-line right"></div>
            <div class="crosshair-dot"></div>
        </div>
        
        <div class="hit-marker" id="hit-marker">‚úï</div>
        <div class="kill-feed" id="kill-feed"></div>
        
        <div class="speed-indicator">
            <div class="speed-value" id="speed-value">0</div>
            <div class="speed-label">km/h</div>
        </div>
        
        <div class="hud-bottom">
            <div class="player-tank-info">
                <div class="player-tank-name" id="player-tank-name">T-34</div>
                <div class="player-hp-bar">
                    <div class="player-hp-fill" id="player-hp-fill"></div>
                    <div class="player-hp-text" id="player-hp-text">1000/1000</div>
                </div>
                <div class="ammo-panel">
                    <div class="ammo-type selected" id="ammo-ap" onclick="selectAmmo('AP')">
                        <span class="key">1</span> AP <span class="ammo-count" id="ap-count">30</span>
                    </div>
                    <div class="ammo-type" id="ammo-he" onclick="selectAmmo('HE')">
                        <span class="key">2</span> HE <span class="ammo-count" id="he-count">15</span>
                    </div>
                </div>
                <div class="reload-bar"><div class="reload-fill" id="reload-fill"></div></div>
            </div>
        </div>
    </div>
    
    <div id="settings-panel">
        <div class="settings-header">
            <h2>‚öôÔ∏è SETTINGS</h2>
            <button class="close-btn" onclick="hideSettings()">‚úï</button>
        </div>
        <div class="settings-tabs">
            <div class="settings-tab active" onclick="switchSettingsTab(0)">DISPLAY</div>
            <div class="settings-tab" onclick="switchSettingsTab(1)">AUDIO</div>
            <div class="settings-tab" onclick="switchSettingsTab(2)">GRAPHICS</div>
            <div class="settings-tab" onclick="switchSettingsTab(3)">CONTROLS</div>
        </div>
        <div class="settings-content" id="settings-content"></div>
    </div>
    
    <div id="game-over">
        <h1 id="game-over-title">VICTORY</h1>
        <div class="game-stats">
            <div class="stat-row"><span>Damage Dealt:</span><span class="stat-value" id="go-damage">0</span></div>
            <div class="stat-row"><span>Tanks Destroyed:</span><span class="stat-value" id="go-kills">0</span></div>
            <div class="stat-row"><span>Shots Fired:</span><span class="stat-value" id="go-shots">0</span></div>
            <div class="stat-row"><span>Accuracy:</span><span class="stat-value" id="go-accuracy">0%</span></div>
        </div>
        <button class="menu-btn" onclick="returnToMenu()">RETURN TO HANGAR</button>
    </div>
    
    <div id="pause-menu">
        <h2>PAUSED</h2>
        <button class="menu-btn" onclick="resumeGame()">RESUME</button>
        <button class="menu-btn" onclick="showSettings()">SETTINGS</button>
        <button class="menu-btn" onclick="quitBattle()">QUIT BATTLE</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const GameState = { LOADING: 'loading', MENU: 'menu', PLAYING: 'playing', PAUSED: 'paused', GAME_OVER: 'game_over' };
        
        let currentState = GameState.LOADING;
        let scene, camera, renderer, clock;
        let playerTank, tanks = [], bullets = [], particles = [];
        let colliders = [];
        let selectedTankIndex = 0, selectedMapIndex = 0;
        let matchTime = 300, matchTimer;
        let gameStats = { damage: 0, kills: 0, shots: 0, hits: 0 };
        let currentSpeed = 0;
        
        const TANKS = [
            { name: 'T-34', nation: '–°–°–°–†', hp: 950, speed: 55, armor: 45, damage: 115, reload: 3.5, color: 0x4a5d23 },
            { name: 'Tiger I', nation: '–ì–µ—Ä–º–∞–Ω–∏—è', hp: 1500, speed: 38, armor: 100, damage: 240, reload: 6.0, color: 0x5c5c5c },
            { name: 'M4 Sherman', nation: '–°–®–ê', hp: 880, speed: 48, armor: 50, damage: 110, reload: 3.2, color: 0x6b5b3c },
            { name: 'Panther', nation: '–ì–µ—Ä–º–∞–Ω–∏—è', hp: 1200, speed: 46, armor: 80, damage: 165, reload: 4.5, color: 0x4d4d4d },
            { name: 'IS-2', nation: '–°–°–°–†', hp: 1400, speed: 37, armor: 90, damage: 280, reload: 8.0, color: 0x3d4a2a },
            { name: 'KV-1', nation: '–°–°–°–†', hp: 1300, speed: 35, armor: 75, damage: 150, reload: 5.0, color: 0x556b2f }
        ];
        
        const MAPS = [
            { name: '–ó–∏–º–Ω—è—è –°—Ç–∞–Ω—Ü–∏—è', type: 'winter', groundColor: 0xe8e8e8, skyColor: 0xb8c4d0, fogColor: 0xc0c8d0 },
            { name: '–ü—Ä–æ—Ö–æ—Ä–æ–≤–∫–∞', type: 'field', groundColor: 0x4a5d23, skyColor: 0x87ceeb, fogColor: 0x87ceeb },
            { name: '–•–∏–º–º–µ–ª—å—Å–¥–æ—Ä—Ñ', type: 'urban', groundColor: 0x4a4a4a, skyColor: 0x7f8c8d, fogColor: 0x7f8c8d },
            { name: '–≠–ª—å-–ê–ª–∞–º–µ–π–Ω', type: 'desert', groundColor: 0xc2a878, skyColor: 0xf5deb3, fogColor: 0xf5deb3 }
        ];
        
        let settings = {
            display: { fov: 75, sensitivity: 1.0 },
            audio: { master: 80, sfx: 100 },
            graphics: { quality: 'high', shadows: true },
            controls: { forward: 'KeyW', back: 'KeyS', left: 'KeyA', right: 'KeyD' }
        };
        
        const keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let isPointerLocked = false;
        
        // Initialize
        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            clock = new THREE.Clock();
            
            setupEventListeners();
            await simulateLoading();
            showMenu();
        }
        
        function setupLighting(mapType) {
            // Clear existing lights
            scene.children = scene.children.filter(c => !c.isLight);
            
            const isWinter = mapType === 'winter';
            
            const ambientLight = new THREE.AmbientLight(isWinter ? 0x8899aa : 0x404040, isWinter ? 0.7 : 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(isWinter ? 0xffffff : 0xffffcc, isWinter ? 0.8 : 1);
            sunLight.position.set(50, 80, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            const hemiLight = new THREE.HemisphereLight(
                isWinter ? 0xaabbcc : 0x87ceeb, 
                isWinter ? 0x445566 : 0x3d4a2a, 
                0.5
            );
            scene.add(hemiLight);
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            renderer.domElement.addEventListener('click', () => {
                if (currentState === GameState.PLAYING && !isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
        }
        
        async function simulateLoading() {
            const progress = document.getElementById('load-progress');
            const text = document.getElementById('loading-text');
            const steps = ['–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤...', '–°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã...', '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–Ω–∫–æ–≤...', '–ì–æ—Ç–æ–≤–æ!'];
            
            for (let i = 0; i <= 100; i += 3) {
                progress.style.width = i + '%';
                text.textContent = steps[Math.floor(i / 30)];
                await new Promise(r => setTimeout(r, 20));
            }
            await new Promise(r => setTimeout(r, 300));
        }
        
        // Menu Functions
        function showMenu() {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('main-menu').style.display = 'block';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            currentState = GameState.MENU;
            createMenuBackground();
        }
        
        function createMenuBackground() {
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            setupLighting('field');
            
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
            
            const groundGeo = new THREE.PlaneGeometry(500, 500);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a5d23, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const displayTank = createTank(TANKS[0], new THREE.Vector3(0, 0, 0));
            scene.add(displayTank.group);
            
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 1, 0);
            
            function animateMenu() {
                if (currentState === GameState.MENU) {
                    displayTank.group.rotation.y += 0.005;
                    renderer.render(scene, camera);
                    requestAnimationFrame(animateMenu);
                }
            }
            animateMenu();
        }
        
        function showTankSelect() {
            document.getElementById('tank-select').style.display = 'block';
            populateTankGrid();
            populateMapGrid();
        }
        
        function hideTankSelect() {
            document.getElementById('tank-select').style.display = 'none';
        }
        
        function populateTankGrid() {
            const grid = document.getElementById('tank-grid');
            grid.innerHTML = '';
            
            TANKS.forEach((tank, i) => {
                const card = document.createElement('div');
                card.className = 'tank-card' + (i === selectedTankIndex ? ' selected' : '');
                card.innerHTML = `
                    <h3>${tank.name}</h3>
                    <div class="nation">${tank.nation}</div>
                    <div class="tank-stats">
                        <div><span>HP</span><div class="stat-bar"><div class="stat-fill" style="width:${tank.hp/16}%"></div></div></div>
                        <div><span>–°–∫–æ—Ä–æ—Å—Ç—å</span><div class="stat-bar"><div class="stat-fill" style="width:${tank.speed*1.5}%"></div></div></div>
                        <div><span>–ë—Ä–æ–Ω—è</span><div class="stat-bar"><div class="stat-fill" style="width:${tank.armor}%"></div></div></div>
                        <div><span>–£—Ä–æ–Ω</span><div class="stat-bar"><div class="stat-fill" style="width:${tank.damage/3}%"></div></div></div>
                    </div>
                `;
                card.onclick = () => { selectedTankIndex = i; populateTankGrid(); };
                grid.appendChild(card);
            });
        }
        
        function populateMapGrid() {
            const grid = document.getElementById('map-grid');
            grid.innerHTML = '';
            
            MAPS.forEach((map, i) => {
                const card = document.createElement('div');
                card.className = 'map-card ' + map.type + (i === selectedMapIndex ? ' selected' : '');
                card.innerHTML = `<h4>${map.name}</h4><p>${map.type === 'winter' ? '‚ùÑÔ∏è –°–Ω–µ–≥' : map.type === 'field' ? 'üåø –ü–æ–ª–µ' : map.type === 'urban' ? 'üèôÔ∏è –ì–æ—Ä–æ–¥' : 'üèúÔ∏è –ü—É—Å—Ç—ã–Ω—è'}</p>`;
                card.onclick = () => { selectedMapIndex = i; populateMapGrid(); };
                grid.appendChild(card);
            });
        }
        
        function showSettings() {
            document.getElementById('settings-panel').style.display = 'block';
            switchSettingsTab(0);
        }
        
        function hideSettings() {
            document.getElementById('settings-panel').style.display = 'none';
        }
        
        function switchSettingsTab(index) {
            const tabs = document.querySelectorAll('.settings-tab');
            tabs.forEach((t, i) => t.classList.toggle('active', i === index));
            
            const content = document.getElementById('settings-content');
            const tabContents = [
                `<div class="setting-row"><span>FOV: ${settings.display.fov}¬∞</span>
                    <input type="range" min="60" max="100" value="${settings.display.fov}" 
                        oninput="settings.display.fov=this.value;this.parentElement.querySelector('span').textContent='FOV: '+this.value+'¬∞'"></div>
                <div class="setting-row"><span>–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${settings.display.sensitivity}</span>
                    <input type="range" min="0.5" max="2" step="0.1" value="${settings.display.sensitivity}" 
                        oninput="settings.display.sensitivity=this.value;this.parentElement.querySelector('span').textContent='–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: '+this.value"></div>`,
                `<div class="setting-row"><span>–û–±—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: ${settings.audio.master}%</span>
                    <input type="range" min="0" max="100" value="${settings.audio.master}" 
                        oninput="settings.audio.master=this.value;this.parentElement.querySelector('span').textContent='–û–±—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: '+this.value+'%'"></div>`,
                `<div class="setting-row"><span>–¢–µ–Ω–∏</span>
                    <div class="toggle ${settings.graphics.shadows?'active':''}" onclick="this.classList.toggle('active');settings.graphics.shadows=this.classList.contains('active')"></div></div>`,
                `<div class="setting-row"><span>–í–ø–µ—Ä—ë–¥</span><span style="color:#f39c12">W</span></div>
                <div class="setting-row"><span>–ù–∞–∑–∞–¥</span><span style="color:#f39c12">S</span></div>
                <div class="setting-row"><span>–í–ª–µ–≤–æ</span><span style="color:#f39c12">A</span></div>
                <div class="setting-row"><span>–í–ø—Ä–∞–≤–æ</span><span style="color:#f39c12">D</span></div>
                <div class="setting-row"><span>–û–≥–æ–Ω—å</span><span style="color:#f39c12">–õ–ö–ú</span></div>`
            ];
            content.innerHTML = tabContents[index];
        }
        
        // Tank Creation
        function createTank(tankDef, position, isPlayer = false, team = 'blue') {
            const group = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: tankDef.color, roughness: 0.7, metalness: 0.3 });
            const trackMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const detailMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.5 });
            
            // Hull
            const hull = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 4), bodyMat);
            hull.position.y = 0.6;
            hull.castShadow = true;
            hull.receiveShadow = true;
            group.add(hull);
            
            // Front slope
            const front = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.5, 1), bodyMat);
            front.position.set(0, 0.85, 2);
            front.rotation.x = -0.3;
            front.castShadow = true;
            group.add(front);
            
            // Turret
            const turretGroup = new THREE.Group();
            const turret = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 1.1, 0.6, 12), bodyMat);
            turret.castShadow = true;
            turretGroup.add(turret);
            
            const turretTop = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.9, 0.3, 12), bodyMat);
            turretTop.position.y = 0.4;
            turretTop.castShadow = true;
            turretGroup.add(turretTop);
            
            // Gun
            const gunGroup = new THREE.Group();
            const gun = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 3, 8), detailMat);
            gun.rotation.x = Math.PI / 2;
            gun.position.z = 1.5;
            gun.castShadow = true;
            gunGroup.add(gun);
            
            const mantlet = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), bodyMat);
            mantlet.scale.set(1, 0.8, 0.6);
            gunGroup.add(mantlet);
            
            gunGroup.position.set(0, 0.15, 0.5);
            turretGroup.add(gunGroup);
            turretGroup.position.set(0, 1.3, -0.3);
            group.add(turretGroup);
            
            // Tracks
            const leftTrack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 4.2), trackMat);
            leftTrack.position.set(-1.3, 0.25, 0);
            leftTrack.castShadow = true;
            group.add(leftTrack);
            
            const rightTrack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 4.2), trackMat);
            rightTrack.position.set(1.3, 0.25, 0);
            rightTrack.castShadow = true;
            group.add(rightTrack);
            
            // Wheels
            for (let i = -1.5; i <= 1.5; i += 0.75) {
                const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 12);
                const leftWheel = new THREE.Mesh(wheelGeo, detailMat);
                leftWheel.rotation.z = Math.PI / 2;
                leftWheel.position.set(-1.3, 0.25, i);
                group.add(leftWheel);
                
                const rightWheel = new THREE.Mesh(wheelGeo, detailMat);
                rightWheel.rotation.z = Math.PI / 2;
                rightWheel.position.set(1.3, 0.25, i);
                group.add(rightWheel);
            }
            
            group.position.copy(position);
            
            return {
                group, turret: turretGroup, gun: gunGroup,
                def: tankDef,
                hp: tankDef.hp, maxHp: tankDef.hp,
                ammo: { AP: 30, HE: 15 },
                selectedAmmo: 'AP',
                reloadTime: 0, isReloading: false,
                isPlayer, team,
                velocity: new THREE.Vector3(),
                turretAngle: 0, gunElevation: 0,
                alive: true,
                radius: 2.5,
                ai: isPlayer ? null : { state: 'patrol', target: null, patrolPoint: new THREE.Vector3() }
            };
        }
        
        // Map Creation with Collision
        function createMap(mapDef) {
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            colliders = [];
            
            setupLighting(mapDef.type);
            
            scene.background = new THREE.Color(mapDef.skyColor);
            scene.fog = new THREE.Fog(mapDef.fogColor, 80, 350);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(400, 400, 40, 40);
            const vertices = groundGeo.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 0.3;
            }
            groundGeo.computeVertexNormals();
            
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: mapDef.groundColor, 
                roughness: mapDef.type === 'winter' ? 0.7 : 0.9,
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            if (mapDef.type === 'winter') {
                createWinterMap();
            } else if (mapDef.type === 'urban') {
                createUrbanMap();
            } else if (mapDef.type === 'field') {
                createFieldMap();
            } else {
                createDesertMap();
            }
        }
        
        function createWinterMap() {
            // Snow-covered buildings
            const buildingMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 });
            const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
            
            const buildingPositions = [
                { x: -40, z: 0, w: 12, h: 8, d: 15 },
                { x: 40, z: 10, w: 10, h: 6, d: 12 },
                { x: 0, z: -60, w: 20, h: 10, d: 8 },
                { x: -60, z: 50, w: 15, h: 7, d: 10 },
                { x: 60, z: -40, w: 8, h: 5, d: 8 },
                { x: 30, z: 60, w: 12, h: 8, d: 14 },
                { x: -30, z: -50, w: 10, h: 6, d: 10 },
            ];
            
            buildingPositions.forEach(b => {
                const building = new THREE.Mesh(new THREE.BoxGeometry(b.w, b.h, b.d), buildingMat);
                building.position.set(b.x, b.h/2, b.z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                
                // Snow on roof
                const roof = new THREE.Mesh(new THREE.BoxGeometry(b.w + 0.5, 0.3, b.d + 0.5), snowMat);
                roof.position.set(b.x, b.h + 0.15, b.z);
                scene.add(roof);
                
                // Add collider
                colliders.push({
                    type: 'box',
                    x: b.x, z: b.z,
                    hw: b.w/2 + 1, hd: b.d/2 + 1
                });
            });
            
            // Frozen trees
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            const snowLeafMat = new THREE.MeshStandardMaterial({ color: 0xddeeff });
            
            for (let i = 0; i < 40; i++) {
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                
                // Check not on buildings
                let valid = true;
                for (const b of buildingPositions) {
                    if (Math.abs(x - b.x) < b.w && Math.abs(z - b.z) < b.d) {
                        valid = false;
                        break;
                    }
                }
                if (!valid) continue;
                
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 2.5, 6), trunkMat);
                trunk.position.y = 1.25;
                tree.add(trunk);
                
                // Snow-covered pine tree
                for (let j = 0; j < 3; j++) {
                    const cone = new THREE.Mesh(
                        new THREE.ConeGeometry(1.8 - j * 0.4, 2 - j * 0.3, 6), 
                        snowLeafMat
                    );
                    cone.position.y = 2.5 + j * 1.2;
                    tree.add(cone);
                }
                
                tree.position.set(x, 0, z);
                tree.castShadow = true;
                scene.add(tree);
                
                colliders.push({ type: 'circle', x, z, r: 0.8 });
            }
            
            // Snow mounds
            for (let i = 0; i < 20; i++) {
                const mound = new THREE.Mesh(
                    new THREE.SphereGeometry(2 + Math.random() * 2, 8, 8),
                    snowMat
                );
                mound.position.set(
                    (Math.random() - 0.5) * 250,
                    0.5,
                    (Math.random() - 0.5) * 250
                );
                mound.scale.y = 0.4;
                mound.receiveShadow = true;
                scene.add(mound);
            }
            
            // Ice patches (decorative)
            const iceMat = new THREE.MeshStandardMaterial({ 
                color: 0xaaddff, 
                roughness: 0.1, 
                metalness: 0.2,
                transparent: true,
                opacity: 0.7
            });
            
            for (let i = 0; i < 5; i++) {
                const ice = new THREE.Mesh(
                    new THREE.CircleGeometry(5 + Math.random() * 5, 12),
                    iceMat
                );
                ice.rotation.x = -Math.PI / 2;
                ice.position.set(
                    (Math.random() - 0.5) * 200,
                    0.02,
                    (Math.random() - 0.5) * 200
                );
                scene.add(ice);
            }
            
            // Destroyed tank wrecks
            const wreckMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 1 });
            for (let i = 0; i < 3; i++) {
                const wreck = new THREE.Group();
                const hull = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.6, 4), wreckMat);
                hull.position.y = 0.3;
                hull.rotation.z = Math.random() * 0.3 - 0.15;
                wreck.add(hull);
                
                wreck.position.set(
                    (Math.random() - 0.5) * 150,
                    0,
                    (Math.random() - 0.5) * 150
                );
                wreck.rotation.y = Math.random() * Math.PI * 2;
                scene.add(wreck);
                
                colliders.push({ type: 'circle', x: wreck.position.x, z: wreck.position.z, r: 3 });
            }
            
            // Rocks
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.9 });
            for (let i = 0; i < 25; i++) {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1 + Math.random() * 1.5, 0),
                    rockMat
                );
                rock.position.set(
                    (Math.random() - 0.5) * 280,
                    0.5,
                    (Math.random() - 0.5) * 280
                );
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.y = 0.6;
                rock.castShadow = true;
                scene.add(rock);
                
                colliders.push({ type: 'circle', x: rock.position.x, z: rock.position.z, r: 1.5 });
            }
        }
        
        function createUrbanMap() {
            const buildingMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
            
            for (let i = 0; i < 25; i++) {
                const w = 5 + Math.random() * 12;
                const h = 5 + Math.random() * 15;
                const d = 5 + Math.random() * 12;
                const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), buildingMat);
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                building.position.set(x, h/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                
                colliders.push({ type: 'box', x, z, hw: w/2 + 1, hd: d/2 + 1 });
            }
        }
        
        function createFieldMap() {
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            
            for (let i = 0; i < 60; i++) {
                const x = (Math.random() - 0.5) * 350;
                const z = (Math.random() - 0.5) * 350;
                
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 3, 6), trunkMat);
                trunk.position.y = 1.5;
                tree.add(trunk);
                
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 6), leafMat);
                leaves.position.y = 5;
                tree.add(leaves);
                
                tree.position.set(x, 0, z);
                tree.castShadow = true;
                scene.add(tree);
                
                colliders.push({ type: 'circle', x, z, r: 0.8 });
            }
            
            // Rocks
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 1 });
            for (let i = 0; i < 30; i++) {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.5 + Math.random() * 1.5, 0),
                    rockMat
                );
                rock.position.set(
                    (Math.random() - 0.5) * 280,
                    0.5,
                    (Math.random() - 0.5) * 280
                );
                rock.scale.y = 0.6;
                rock.castShadow = true;
                scene.add(rock);
                
                colliders.push({ type: 'circle', x: rock.position.x, z: rock.position.z, r: 1.5 });
            }
        }
        
        function createDesertMap() {
            // Sand dunes
            const sandMat = new THREE.MeshStandardMaterial({ color: 0xc2a878, roughness: 1 });
            
            for (let i = 0; i < 15; i++) {
                const dune = new THREE.Mesh(
                    new THREE.SphereGeometry(8 + Math.random() * 10, 12, 12),
                    sandMat
                );
                dune.position.set(
                    (Math.random() - 0.5) * 300,
                    -2,
                    (Math.random() - 0.5) * 300
                );
                dune.scale.y = 0.3;
                dune.receiveShadow = true;
                scene.add(dune);
            }
            
            // Rocks
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 1 });
            for (let i = 0; i < 20; i++) {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1 + Math.random() * 2, 0),
                    rockMat
                );
                const x = (Math.random() - 0.5) * 250;
                const z = (Math.random() - 0.5) * 250;
                rock.position.set(x, 0.5, z);
                rock.scale.y = 0.7;
                rock.castShadow = true;
                scene.add(rock);
                
                colliders.push({ type: 'circle', x, z, r: 2 });
            }
        }
        
        // Collision Detection
        function checkCollision(x, z, radius, excludeTank = null) {
            // Check against static colliders
            for (const col of colliders) {
                if (col.type === 'box') {
                    const dx = Math.abs(x - col.x);
                    const dz = Math.abs(z - col.z);
                    if (dx < col.hw + radius && dz < col.hd + radius) {
                        return true;
                    }
                } else if (col.type === 'circle') {
                    const dist = Math.sqrt((x - col.x) ** 2 + (z - col.z) ** 2);
                    if (dist < col.r + radius) {
                        return true;
                    }
                }
            }
            
            // Check against other tanks
            for (const tank of tanks) {
                if (tank === excludeTank || !tank.alive) continue;
                const dist = Math.sqrt((x - tank.group.position.x) ** 2 + (z - tank.group.position.z) ** 2);
                if (dist < tank.radius + radius) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Battle Logic
        function startBattle() {
            hideTankSelect();
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            
            currentState = GameState.PLAYING;
            gameStats = { damage: 0, kills: 0, shots: 0, hits: 0 };
            matchTime = 300;
            tanks = [];
            bullets = [];
            particles = [];
            mouse = { x: 0, y: 0, down: false };
            
            createMap(MAPS[selectedMapIndex]);
            
            // Player
            playerTank = createTank(TANKS[selectedTankIndex], new THREE.Vector3(0, 0, -80), true, 'blue');
            scene.add(playerTank.group);
            tanks.push(playerTank);
            
            // Friendly AI
            const blueSpawns = [
                new THREE.Vector3(-25, 0, -70),
                new THREE.Vector3(25, 0, -70),
                new THREE.Vector3(-40, 0, -60),
                new THREE.Vector3(40, 0, -60),
                new THREE.Vector3(-15, 0, -90),
                new THREE.Vector3(15, 0, -90)
            ];
            
            blueSpawns.forEach((pos, i) => {
                const tank = createTank(TANKS[(i + 1) % TANKS.length], pos, false, 'blue');
                scene.add(tank.group);
                tanks.push(tank);
            });
            
            // Enemy AI
            const redSpawns = [
                new THREE.Vector3(-25, 0, 70),
                new THREE.Vector3(0, 0, 80),
                new THREE.Vector3(25, 0, 70),
                new THREE.Vector3(-40, 0, 60),
                new THREE.Vector3(40, 0, 60),
                new THREE.Vector3(-15, 0, 90),
                new THREE.Vector3(15, 0, 90)
            ];
            
            redSpawns.forEach((pos, i) => {
                const tank = createTank(TANKS[i % TANKS.length], pos, false, 'red');
                tank.group.rotation.y = Math.PI;
                scene.add(tank.group);
                tanks.push(tank);
            });
            
            document.getElementById('player-tank-name').textContent = TANKS[selectedTankIndex].name;
            updatePlayerHUD();
            updateScores();
            
            matchTimer = setInterval(() => {
                matchTime--;
                updateTimer();
                if (matchTime <= 0) endMatch('draw');
            }, 1000);
            
            renderer.domElement.requestPointerLock();
            clock.start();
            gameLoop();
        }
        
        function gameLoop() {
            if (currentState !== GameState.PLAYING) return;
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            updatePlayer(delta);
            
            tanks.forEach(tank => {
                if (!tank.isPlayer && tank.alive) {
                    updateAI(tank, delta);
                }
                // Reload
                if (tank.isReloading) {
                    tank.reloadTime -= delta;
                    if (tank.reloadTime <= 0) {
                        tank.isReloading = false;
                    }
                }
            });
            
            updateBullets(delta);
            updateParticles(delta);
            updateCamera();
            updateMinimap();
            
            // Player reload UI
            if (playerTank && playerTank.isReloading) {
                const progress = 1 - (playerTank.reloadTime / playerTank.def.reload);
                document.getElementById('reload-fill').style.width = (progress * 100) + '%';
            } else if (playerTank) {
                document.getElementById('reload-fill').style.width = '100%';
            }
            
            renderer.render(scene, camera);
            checkWinConditions();
            
            requestAnimationFrame(gameLoop);
        }
        
        function updatePlayer(delta) {
            if (!playerTank || !playerTank.alive) return;
            
            const maxSpeed = playerTank.def.speed * 0.12;
            const accel = maxSpeed * 2;
            const friction = maxSpeed * 3;
            const rotSpeed = 1.8;
            
            let targetSpeed = 0;
            
            if (keys[settings.controls.forward] || keys['KeyW']) {
                targetSpeed = maxSpeed;
            } else if (keys[settings.controls.back] || keys['KeyS']) {
                targetSpeed = -maxSpeed * 0.5;
            }
            
            // Accelerate/decelerate
            if (targetSpeed !== 0) {
                currentSpeed += Math.sign(targetSpeed - currentSpeed) * accel * delta;
                if (Math.abs(currentSpeed) > Math.abs(targetSpeed)) {
                    currentSpeed = targetSpeed;
                }
            } else {
                if (Math.abs(currentSpeed) > 0.01) {
                    currentSpeed -= Math.sign(currentSpeed) * friction * delta;
                } else {
                    currentSpeed = 0;
                }
            }
            
            // Rotation
            if (keys[settings.controls.left] || keys['KeyA']) {
                playerTank.group.rotation.y += rotSpeed * delta;
            }
            if (keys[settings.controls.right] || keys['KeyD']) {
                playerTank.group.rotation.y -= rotSpeed * delta;
            }
            
            // Calculate new position
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(playerTank.group.quaternion);
            
            const newX = playerTank.group.position.x + forward.x * currentSpeed * delta;
            const newZ = playerTank.group.position.z + forward.z * currentSpeed * delta;
            
            // Collision check
            if (!checkCollision(newX, newZ, playerTank.radius, playerTank)) {
                playerTank.group.position.x = newX;
                playerTank.group.position.z = newZ;
            } else {
                currentSpeed *= -0.3; // Bounce back slightly
            }
            
            // Bounds
            const bounds = 180;
            playerTank.group.position.x = Math.max(-bounds, Math.min(bounds, playerTank.group.position.x));
            playerTank.group.position.z = Math.max(-bounds, Math.min(bounds, playerTank.group.position.z));
            
            // Turret rotation
            const sens = settings.display.sensitivity || 1;
            const targetAngle = -mouse.x * Math.PI * sens;
            playerTank.turretAngle += (targetAngle - playerTank.turretAngle) * 8 * delta;
            playerTank.turret.rotation.y = playerTank.turretAngle;
            
            // Gun elevation
            const targetElevation = Math.max(-0.15, Math.min(0.25, -mouse.y * 0.4));
            playerTank.gunElevation += (targetElevation - playerTank.gunElevation) * 8 * delta;
            playerTank.gun.rotation.x = playerTank.gunElevation;
            
            // Speed display
            document.getElementById('speed-value').textContent = Math.abs(Math.round(currentSpeed * 10));
            
            // Fire
            if (mouse.down && !playerTank.isReloading) {
                fireTank(playerTank);
            }
        }
        
        function updateAI(tank, delta) {
            if (!tank.ai) return;
            
            const speed = tank.def.speed * 0.08;
            
            // Find target
            let closestEnemy = null;
            let closestDist = Infinity;
            
            tanks.forEach(other => {
                if (other.alive && other.team !== tank.team) {
                    const dist = tank.group.position.distanceTo(other.group.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestEnemy = other;
                    }
                }
            });
            
            if (closestEnemy && closestDist < 120) {
                tank.ai.target = closestEnemy;
                tank.ai.state = 'combat';
            } else {
                tank.ai.state = 'patrol';
            }
            
            if (tank.ai.state === 'combat' && tank.ai.target) {
                const targetPos = tank.ai.target.group.position;
                const angle = Math.atan2(
                    targetPos.x - tank.group.position.x,
                    targetPos.z - tank.group.position.z
                );
                
                let angleDiff = angle - tank.group.rotation.y;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                tank.group.rotation.y += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), delta * 1.2);
                
                const turretAngle = angle - tank.group.rotation.y;
                tank.turret.rotation.y = turretAngle;
                
                // Move with collision
                if (closestDist > 40) {
                    const forward = new THREE.Vector3(0, 0, 1);
                    forward.applyQuaternion(tank.group.quaternion);
                    const newX = tank.group.position.x + forward.x * speed * delta;
                    const newZ = tank.group.position.z + forward.z * speed * delta;
                    
                    if (!checkCollision(newX, newZ, tank.radius, tank)) {
                        tank.group.position.x = newX;
                        tank.group.position.z = newZ;
                    }
                }
                
                if (Math.abs(angleDiff) < 0.25 && !tank.isReloading && Math.random() < 0.03) {
                    fireTank(tank);
                }
            } else {
                // Patrol
                if (!tank.ai.patrolPoint || tank.group.position.distanceTo(tank.ai.patrolPoint) < 15) {
                    tank.ai.patrolPoint = new THREE.Vector3(
                        (Math.random() - 0.5) * 120,
                        0,
                        (Math.random() - 0.5) * 120
                    );
                }
                
                const angle = Math.atan2(
                    tank.ai.patrolPoint.x - tank.group.position.x,
                    tank.ai.patrolPoint.z - tank.group.position.z
                );
                
                let angleDiff = angle - tank.group.rotation.y;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                tank.group.rotation.y += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), delta * 0.8);
                
                if (Math.abs(angleDiff) < 0.5) {
                    const forward = new THREE.Vector3(0, 0, 1);
                    forward.applyQuaternion(tank.group.quaternion);
                    const newX = tank.group.position.x + forward.x * speed * 0.5 * delta;
                    const newZ = tank.group.position.z + forward.z * speed * 0.5 * delta;
                    
                    if (!checkCollision(newX, newZ, tank.radius, tank)) {
                        tank.group.position.x = newX;
                        tank.group.position.z = newZ;
                    } else {
                        tank.ai.patrolPoint = null;
                    }
                }
            }
            
            // Bounds
            const bounds = 170;
            tank.group.position.x = Math.max(-bounds, Math.min(bounds, tank.group.position.x));
            tank.group.position.z = Math.max(-bounds, Math.min(bounds, tank.group.position.z));
        }
        
        function fireTank(tank) {
            if (tank.ammo[tank.selectedAmmo] <= 0) return;
            
            tank.ammo[tank.selectedAmmo]--;
            tank.isReloading = true;
            tank.reloadTime = tank.def.reload;
            
            if (tank.isPlayer) {
                gameStats.shots++;
                updateAmmoDisplay();
            }
            
            const gunPos = new THREE.Vector3();
            tank.gun.getWorldPosition(gunPos);
            
            // Get gun direction
            const gunDir = new THREE.Vector3(0, 0, 1);
            const gunQuat = new THREE.Quaternion();
            tank.gun.getWorldQuaternion(gunQuat);
            gunDir.applyQuaternion(gunQuat);
            
            // Create bullet
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            bullet.position.copy(gunPos).add(gunDir.clone().multiplyScalar(1.5));
            scene.add(bullet);
            
            bullets.push({
                mesh: bullet,
                velocity: gunDir.clone().multiplyScalar(180),
                owner: tank,
                type: tank.selectedAmmo,
                damage: tank.def.damage * (tank.selectedAmmo === 'HE' ? 0.7 : 1),
                penetration: tank.selectedAmmo === 'AP' ? 150 : 50,
                life: 4
            });
            
            // Muzzle flash
            createMuzzleFlash(bullet.position.clone());
            
            // Recoil
            const originalZ = tank.gun.position.z;
            tank.gun.position.z -= 0.25;
            setTimeout(() => { if (tank.gun) tank.gun.position.z = originalZ; }, 80);
        }
        
        function createMuzzleFlash(position) {
            const flash = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1 })
            );
            flash.position.copy(position);
            scene.add(flash);
            particles.push({ mesh: flash, life: 0.08, type: 'flash' });
        }
        
        function createExplosion(position, size = 1) {
            const explosion = new THREE.Mesh(
                new THREE.SphereGeometry(size, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 1 })
            );
            explosion.position.copy(position);
            scene.add(explosion);
            particles.push({ mesh: explosion, life: 0.4, type: 'explosion', scale: size });
            
            for (let i = 0; i < 4; i++) {
                const smoke = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4 + Math.random() * 0.4, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.7 })
                );
                smoke.position.copy(position).add(new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 1.5,
                    (Math.random() - 0.5) * 2
                ));
                scene.add(smoke);
                particles.push({
                    mesh: smoke, life: 1.2 + Math.random() * 0.5, type: 'smoke',
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 4, 2 + Math.random() * 2, (Math.random() - 0.5) * 4)
                });
            }
        }
        
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.life -= delta;
                
                if (bullet.life <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }
                
                const movement = bullet.velocity.clone().multiplyScalar(delta);
                bullet.mesh.position.add(movement);
                
                // Tank collision
                for (const tank of tanks) {
                    if (!tank.alive || tank === bullet.owner) continue;
                    
                    const dist = bullet.mesh.position.distanceTo(tank.group.position);
                    if (dist < 2.8) {
                        const penetrated = bullet.penetration > tank.def.armor * (0.7 + Math.random() * 0.6);
                        
                        if (penetrated) {
                            const dmg = Math.round(bullet.damage * (0.85 + Math.random() * 0.3));
                            tank.hp -= dmg;
                            
                            if (bullet.owner.isPlayer) {
                                gameStats.damage += dmg;
                                gameStats.hits++;
                                showHitMarker();
                            }
                            
                            if (tank.isPlayer) {
                                showDamageIndicator(dmg);
                                updatePlayerHUD();
                            }
                            
                            if (tank.hp <= 0) destroyTank(tank, bullet.owner);
                        } else if (bullet.owner.isPlayer) {
                            showNotification('–†–∏–∫–æ—à–µ—Ç!');
                        }
                        
                        createExplosion(bullet.mesh.position, 0.6);
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                        break;
                    }
                }
                
                // Ground/building collision
                if (bullet.mesh.position.y < 0 || checkCollision(bullet.mesh.position.x, bullet.mesh.position.z, 0.2)) {
                    createExplosion(bullet.mesh.position, 0.4);
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function destroyTank(tank, killer) {
            tank.alive = false;
            tank.group.rotation.x = 0.15;
            tank.group.rotation.z = 0.1;
            
            createExplosion(tank.group.position.clone().add(new THREE.Vector3(0, 1.5, 0)), 3);
            
            tank.group.traverse(child => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 });
                }
            });
            
            if (killer.isPlayer) gameStats.kills++;
            
            addKillFeed(killer.def.name, tank.def.name, killer.team, tank.team);
            updateScores();
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= delta;
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                    continue;
                }
                
                if (p.type === 'explosion') {
                    p.mesh.scale.setScalar(p.scale * (1 + (0.4 - p.life) * 5));
                    p.mesh.material.opacity = p.life * 2.5;
                } else if (p.type === 'smoke') {
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                    p.velocity.y -= delta * 1.5;
                    p.mesh.material.opacity = Math.min(0.7, p.life * 0.7);
                    p.mesh.scale.setScalar(1 + (1.2 - p.life) * 1.5);
                } else if (p.type === 'flash') {
                    p.mesh.material.opacity = p.life * 12;
                }
            }
        }
        
        function updateCamera() {
            if (!playerTank) return;
            
            const offset = new THREE.Vector3(0, 5, -10);
            offset.applyQuaternion(playerTank.group.quaternion);
            
            const targetPos = playerTank.group.position.clone().add(offset);
            camera.position.lerp(targetPos, 0.08);
            
            const lookTarget = playerTank.group.position.clone();
            lookTarget.y += 1.5;
            camera.lookAt(lookTarget);
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            
            const mapType = MAPS[selectedMapIndex].type;
            ctx.fillStyle = mapType === 'winter' ? '#aabbcc' : mapType === 'desert' ? '#c2a878' : '#2a3a2a';
            ctx.fillRect(0, 0, 180, 180);
            
            const scale = 0.45;
            const cx = 90, cy = 90;
            
            // Draw colliders
            ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
            colliders.forEach(col => {
                if (col.type === 'box') {
                    const x = cx + col.x * scale;
                    const y = cy + col.z * scale;
                    ctx.fillRect(x - col.hw * scale, y - col.hd * scale, col.hw * 2 * scale, col.hd * 2 * scale);
                }
            });
            
            tanks.forEach(tank => {
                if (!tank.alive) return;
                
                const x = cx + (tank.group.position.x - playerTank.group.position.x) * scale;
                const y = cy + (tank.group.position.z - playerTank.group.position.z) * scale;
                
                if (x < 5 || x > 175 || y < 5 || y > 175) return;
                
                ctx.beginPath();
                ctx.fillStyle = tank.isPlayer ? '#00ff00' : tank.team === 'blue' ? '#3498db' : '#e74c3c';
                ctx.arc(x, y, tank.isPlayer ? 5 : 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Direction indicator for player
                if (tank.isPlayer) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    const dir = tank.group.rotation.y;
                    ctx.lineTo(x + Math.sin(dir) * 10, y + Math.cos(dir) * 10);
                    ctx.stroke();
                }
            });
        }
        
        function updatePlayerHUD() {
            if (!playerTank) return;
            const hpPercent = (playerTank.hp / playerTank.maxHp) * 100;
            document.getElementById('player-hp-fill').style.width = hpPercent + '%';
            document.getElementById('player-hp-text').textContent = `${Math.max(0, Math.round(playerTank.hp))}/${playerTank.maxHp}`;
            
            const hpFill = document.getElementById('player-hp-fill');
            if (hpPercent > 50) hpFill.style.background = 'linear-gradient(90deg, #27ae60, #2ecc71)';
            else if (hpPercent > 25) hpFill.style.background = 'linear-gradient(90deg, #f39c12, #e67e22)';
            else hpFill.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
        }
        
        function updateAmmoDisplay() {
            if (!playerTank) return;
            document.getElementById('ap-count').textContent = playerTank.ammo.AP;
            document.getElementById('he-count').textContent = playerTank.ammo.HE;
        }
        
        function updateTimer() {
            const mins = Math.floor(matchTime / 60);
            const secs = matchTime % 60;
            document.getElementById('match-timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateScores() {
            let blueAlive = 0, redAlive = 0;
            tanks.forEach(t => {
                if (t.alive) t.team === 'blue' ? blueAlive++ : redAlive++;
            });
            document.getElementById('blue-score').textContent = blueAlive;
            document.getElementById('red-score').textContent = redAlive;
        }
        
        function selectAmmo(type) {
            if (!playerTank) return;
            playerTank.selectedAmmo = type;
            document.getElementById('ammo-ap').classList.toggle('selected', type === 'AP');
            document.getElementById('ammo-he').classList.toggle('selected', type === 'HE');
        }
        
        function showHitMarker() {
            const marker = document.getElementById('hit-marker');
            marker.classList.remove('show');
            void marker.offsetWidth;
            marker.classList.add('show');
        }
        
        function showDamageIndicator(damage) {
            const ind = document.createElement('div');
            ind.className = 'damage-indicator';
            ind.textContent = `-${damage}`;
            document.getElementById('hud').appendChild(ind);
            setTimeout(() => ind.remove(), 1000);
        }
        
        function addKillFeed(killer, victim, killerTeam, victimTeam) {
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.className = 'kill-entry';
            entry.innerHTML = `<span class="${killerTeam === 'blue' ? 'killer' : 'victim'}">${killer}</span> —É–Ω–∏—á—Ç–æ–∂–∏–ª <span class="${victimTeam === 'blue' ? 'killer' : 'victim'}">${victim}</span>`;
            feed.appendChild(entry);
            setTimeout(() => entry.remove(), 4000);
        }
        
        function showNotification(text) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = text;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }
        
        function checkWinConditions() {
            let blueAlive = 0, redAlive = 0;
            tanks.forEach(t => { if (t.alive) t.team === 'blue' ? blueAlive++ : redAlive++; });
            
            if (blueAlive === 0) endMatch('defeat');
            else if (redAlive === 0) endMatch('victory');
        }
        
        function endMatch(result) {
            clearInterval(matchTimer);
            currentState = GameState.GAME_OVER;
            document.exitPointerLock();
            
            const gameOver = document.getElementById('game-over');
            gameOver.style.display = 'flex';
            gameOver.className = result === 'victory' ? 'victory' : 'defeat';
            document.getElementById('game-over-title').textContent = result === 'victory' ? '–ü–û–ë–ï–î–ê!' : '–ü–û–†–ê–ñ–ï–ù–ò–ï';
            
            const accuracy = gameStats.shots > 0 ? Math.round((gameStats.hits / gameStats.shots) * 100) : 0;
            document.getElementById('go-damage').textContent = gameStats.damage;
            document.getElementById('go-kills').textContent = gameStats.kills;
            document.getElementById('go-shots').textContent = gameStats.shots;
            document.getElementById('go-accuracy').textContent = accuracy + '%';
        }
        
        function returnToMenu() {
            document.getElementById('game-over').style.display = 'none';
            showMenu();
        }
        
        function resumeGame() {
            document.getElementById('pause-menu').style.display = 'none';
            currentState = GameState.PLAYING;
            renderer.domElement.requestPointerLock();
            clock.start();
            gameLoop();
        }
        
        function quitBattle() {
            document.getElementById('pause-menu').style.display = 'none';
            clearInterval(matchTimer);
            currentState = GameState.MENU;
            showMenu();
        }
        
        // Input
        function onKeyDown(e) {
            keys[e.code] = true;
            
            if (currentState === GameState.PLAYING) {
                if (e.code === 'Digit1') selectAmmo('AP');
                if (e.code === 'Digit2') selectAmmo('HE');
                if (e.code === 'Escape') {
                    currentState = GameState.PAUSED;
                    document.exitPointerLock();
                    document.getElementById('pause-menu').style.display = 'block';
                }
            }
        }
        
        function onKeyUp(e) { keys[e.code] = false; }
        
        function onMouseMove(e) {
            if (isPointerLocked && currentState === GameState.PLAYING) {
                const sens = (settings.display.sensitivity || 1) * 0.002;
                mouse.x += e.movementX * sens;
                mouse.y += e.movementY * sens;
                mouse.x = Math.max(-1, Math.min(1, mouse.x));
                mouse.y = Math.max(-0.8, Math.min(0.8, mouse.y));
            }
        }
        
        function onMouseDown(e) { if (e.button === 0) mouse.down = true; }
        function onMouseUp(e) { if (e.button === 0) mouse.down = false; }
        
        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
