<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>FPS Training: Day Mode</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { margin: 0; overflow: hidden; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Mobile Controls */
        #joystick-zone { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; background: rgba(0,0,0,0.1); border-radius: 50%; pointer-events: auto; touch-action: none; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        
        #look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; touch-action: none; z-index: 5; }
        
        #mobile-buttons { position: absolute; bottom: 40px; right: 20px; display: flex; flex-direction: column; gap: 15px; pointer-events: auto; z-index: 10; }
        .game-btn { width: 70px; height: 70px; background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; touch-action: manipulation; user-select: none; active: scale(0.95); }
        .game-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; }
        .crosshair-line { position: absolute; background-color: rgba(0, 255, 0, 0.8); }
        .h-line { top: 9px; left: 0; width: 20px; height: 2px; }
        .v-line { left: 9px; top: 0; width: 2px; height: 20px; }

        #ammo-display { position: absolute; bottom: 20px; right: 20px; color: white; font-family: monospace; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 2px black; display: none; } /* Hidden on mobile initially, logic will toggle */
        
        @media (min-width: 768px) {
            #mobile-controls { display: none; }
            #ammo-display { display: block; }
        }
        @media (max-width: 767px) {
            #ammo-display { top: 20px; right: 20px; bottom: auto; }
        }
    </style>
</head>
<body class="bg-blue-300">

    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-line h-line"></div>
            <div class="crosshair-line v-line"></div>
        </div>

        <!-- Info / Ammo -->
        <div id="ammo-display">
            <div id="weapon-info">AMMO: <span id="ammo-count">30</span> / <span id="weapon-name">AK-47</span></div>
        </div>

        <!-- Zombie HUD -->
        <div id="zombie-hud" class="hidden absolute top-4 left-4 text-white font-bold font-mono text-xl pointer-events-none">
            <div class="mb-2 text-red-500">HEALTH: <span id="player-health">100</span>%</div>
            <div class="mb-2 text-yellow-400">WAVE: <span id="wave-num">1</span></div>
            <div class="text-gray-300">ZOMBIES: <span id="zombie-count">0</span></div>
        </div>

        <!-- Start Screen / Main Menu -->
        <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/90 text-white pointer-events-auto z-50 transition-opacity duration-300">
            <h1 class="text-5xl font-extrabold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-yellow-500">FPS MASTER</h1>
            
            <!-- Main Menu Buttons -->
            <div id="main-menu" class="flex flex-col gap-4 w-64">
                <button id="btn-mode-training" class="px-6 py-4 bg-blue-600 hover:bg-blue-500 rounded text-xl font-bold shadow-lg transform hover:scale-105 transition">TRAINING MODE</button>
                <button id="btn-mode-zombies" class="px-6 py-4 bg-red-700 hover:bg-red-600 rounded text-xl font-bold shadow-lg transform hover:scale-105 transition">ZOMBIE WAVES</button>
            </div>

            <!-- Zombie Config Screen (Hidden) -->
            <div id="zombie-config" class="hidden flex flex-col gap-4 w-80 bg-gray-800 p-6 rounded-lg shadow-2xl border border-gray-700">
                <h2 class="text-2xl font-bold text-center mb-4 text-red-500">WAVE SETTINGS</h2>
                
                <div class="flex flex-col gap-2">
                    <label class="text-sm text-gray-400">Zombies per Wave</label>
                    <input type="range" id="cfg-count" min="5" max="50" value="10" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="val-count" class="text-right font-mono">10</span>
                </div>

                <div class="flex flex-col gap-2">
                    <label class="text-sm text-gray-400">Zombie Speed</label>
                    <input type="range" id="cfg-speed" min="1" max="10" value="3" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="val-speed" class="text-right font-mono">3</span>
                </div>

                <div class="flex flex-col gap-2">
                    <label class="text-sm text-gray-400">Spawn Rate (ms)</label>
                    <input type="range" id="cfg-rate" min="500" max="5000" step="500" value="2000" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="val-rate" class="text-right font-mono">2000ms</span>
                </div>

                <div class="flex gap-4 mt-4">
                    <button id="btn-back-menu" class="flex-1 py-2 bg-gray-600 hover:bg-gray-500 rounded font-bold">BACK</button>
                    <button id="btn-start-zombies" class="flex-1 py-2 bg-green-600 hover:bg-green-500 rounded font-bold">START</button>
                </div>
            </div>

            <p class="mt-8 text-gray-400 text-sm max-w-md text-center">
                PC: WASD Move, Mouse Look/Shoot, F Inspect, 1-3 Swap<br>
                Mobile: Joystick Move, Right Screen Look, Buttons Shoot
            </p>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls" class="hidden md:hidden">
            <div id="joystick-zone">
                <div id="joystick-knob"></div>
            </div>
            
            <!-- Right side look zone is invisible overlay -->
            <div id="look-zone"></div>

            <div id="mobile-buttons">
                <button id="btn-inspect" class="game-btn text-sm">INSP</button>
                <button id="btn-switch" class="game-btn">SWAP</button>
                <button id="btn-shoot" class="game-btn bg-red-500/30 border-red-400">FIRE</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const config = {
            speed: 5.0, // Reduced speed
            jumpForce: 10.0,
            gravity: 30.0,
            lookSensitivity: 0.002,
            touchLookSensitivity: 0.005,
            playerHeight: 1.8,
            playerRadius: 0.5
        };

        // --- Globals ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let touchMove = { x: 0, y: 0 }; // Joystick input -1 to 1
        
        const objects = []; // Collidable objects
        const targets = [];
        const bullets = [];
        let raycaster;
        
        // Game Modes
        let gameMode = 'none'; // 'training', 'zombies'
        let zombieConfig = { count: 10, speed: 3, rate: 2000 };
        let zombies = [];
        let waveNum = 0;
        let zombiesRemaining = 0;
        let playerHealth = 100;
        let lastZombieSpawnTime = 0;
        let zombiesSpawnedInWave = 0;
        let waveInProgress = false;
        
        // Weapon System
        let currentWeaponIdx = 0; // 0: AK47, 1: Knife
        let weapons = [];
        let isShooting = false;
        let isInspecting = false;
        let inspectStartTime = 0;
        let lastShootTime = 0;
        let weaponContainer; // Child of camera
        
        // --- Initialization ---
        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');

            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Day sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 75);

            // Lighting for Day Mode
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8); // Bright sky
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); // Sun
            dirLight.position.set(10, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = config.playerHeight;

            // 2. Weapon Models (Attached to Camera)
            weaponContainer = new THREE.Group();
            camera.add(weaponContainer);
            
            // AK-47 Model (Simplified)
            const akGroup = new THREE.Group();
            
            // Body
            const akBodyGeo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const akBodyMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const akBody = new THREE.Mesh(akBodyGeo, akBodyMat);
            akBody.position.set(0, 0, 0);
            akGroup.add(akBody);
            
            // Wood Stock
            const akStockGeo = new THREE.BoxGeometry(0.08, 0.12, 0.3);
            const akWoodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const akStock = new THREE.Mesh(akStockGeo, akWoodMat);
            akStock.position.set(0, -0.05, 0.4);
            akGroup.add(akStock);
            
            // Barrel
            const akBarrelGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8);
            const akBarrel = new THREE.Mesh(akBarrelGeo, akBodyMat);
            akBarrel.rotation.x = Math.PI / 2;
            akBarrel.position.set(0, 0.02, -0.5);
            akGroup.add(akBarrel);
            
            // Magazine
            const akMagGeo = new THREE.BoxGeometry(0.04, 0.2, 0.1);
            const akMag = new THREE.Mesh(akMagGeo, akBodyMat);
            akMag.rotation.x = Math.PI / 8;
            akMag.position.set(0, -0.15, -0.1);
            akGroup.add(akMag);

            akGroup.position.set(0.3, -0.4, -0.5); // Initial position relative to camera
            akGroup.visible = true;
            weapons.push({ mesh: akGroup, name: "AK-47", type: 'gun', fireRate: 100, damage: 25 });
            weaponContainer.add(akGroup);

            // Butterfly Knife Model (Simplified)
            const knifeGroup = new THREE.Group();
            // Handle
            const knifeHandleGeo = new THREE.BoxGeometry(0.03, 0.03, 0.2);
            const knifeHandleMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Gold/Brass handle
            const knifeHandle = new THREE.Mesh(knifeHandleGeo, knifeHandleMat);
            knifeHandle.position.set(0, 0, 0.1);
            knifeGroup.add(knifeHandle);
            // Blade
            const knifeBladeGeo = new THREE.BoxGeometry(0.01, 0.04, 0.25);
            const knifeBladeMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.8, roughness: 0.2 });
            const knifeBlade = new THREE.Mesh(knifeBladeGeo, knifeBladeMat);
            knifeBlade.position.set(0, 0, -0.15);
            knifeGroup.add(knifeBlade);

            knifeGroup.position.set(0.3, -0.4, -0.4);
            knifeGroup.rotation.set(0.2, -0.1, 0);
            knifeGroup.visible = false;
            weapons.push({ mesh: knifeGroup, name: "Butterfly Knife", type: 'melee', fireRate: 400, damage: 50 });
            weaponContainer.add(knifeGroup);

            // CZ75-Auto Model
            const czGroup = new THREE.Group();
            // Handle
            const czHandleGeo = new THREE.BoxGeometry(0.04, 0.12, 0.05);
            const czHandleMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const czHandle = new THREE.Mesh(czHandleGeo, czHandleMat);
            czHandle.rotation.x = -0.2;
            czHandle.position.set(0, -0.05, 0.05);
            czGroup.add(czHandle);
            // Slide
            const czSlideGeo = new THREE.BoxGeometry(0.05, 0.05, 0.2);
            const czSlideMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.2 });
            const czSlide = new THREE.Mesh(czSlideGeo, czSlideMat);
            czSlide.position.set(0, 0.02, -0.05);
            czGroup.add(czSlide);
            // Barrel
            const czBarrelGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.25);
            const czBarrel = new THREE.Mesh(czBarrelGeo, new THREE.MeshStandardMaterial({ color: 0x111111 }));
            czBarrel.rotation.x = Math.PI / 2;
            czBarrel.position.set(0, 0.02, -0.05);
            czGroup.add(czBarrel);

            czGroup.position.set(0.3, -0.35, -0.4);
            czGroup.visible = false;
            weapons.push({ mesh: czGroup, name: "CZ75-Auto", type: 'gun', fireRate: 80, damage: 15 });
            weaponContainer.add(czGroup);


            // 3. World Generation
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22, // Forest Green for zombie/training field
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = - Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid for better movement perception
            const gridHelper = new THREE.GridHelper(200, 50, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Walls/Obstacles (Basic Arena)
            const boxGeo = new THREE.BoxGeometry(20, 5, 1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            
            const wall1 = new THREE.Mesh(boxGeo, boxMat);
            wall1.position.set(0, 2.5, -20);
            scene.add(wall1);
            objects.push(wall1);

            const wall2 = new THREE.Mesh(boxGeo, boxMat);
            wall2.position.set(0, 2.5, 20);
            scene.add(wall2);
            objects.push(wall2);

            const wall3 = new THREE.Mesh(boxGeo, boxMat);
            wall3.rotation.y = Math.PI / 2;
            wall3.position.set(-20, 2.5, 0);
            scene.add(wall3);
            objects.push(wall3);

            const wall4 = new THREE.Mesh(boxGeo, boxMat);
            wall4.rotation.y = Math.PI / 2;
            wall4.position.set(20, 2.5, 0);
            scene.add(wall4);
            objects.push(wall4);

            // Crates for cover
            const crateGeo = new THREE.BoxGeometry(2, 2, 2);
            const crateMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Wood
            for(let i=0; i<5; i++) {
                const crate = new THREE.Mesh(crateGeo, crateMat);
                crate.position.set(
                    (Math.random() - 0.5) * 30,
                    1,
                    (Math.random() - 0.5) * 30
                );
                crate.castShadow = true;
                crate.receiveShadow = true;
                scene.add(crate);
                objects.push(crate);
            }

            // Targets will be created if Training Mode is selected

            // 4. Controls
            controls = new PointerLockControls(camera, document.body);

            // UI Elements
            const startScreen = document.getElementById('start-screen');
            const mainMenu = document.getElementById('main-menu');
            const zombieConfigDiv = document.getElementById('zombie-config');
            const btnTraining = document.getElementById('btn-mode-training');
            const btnZombies = document.getElementById('btn-mode-zombies');
            const btnBack = document.getElementById('btn-back-menu');
            const btnStartZombies = document.getElementById('btn-start-zombies');
            const mobileControls = document.getElementById('mobile-controls');
            const zombieHud = document.getElementById('zombie-hud');

            // --- Menu Logic ---
            btnTraining.addEventListener('click', () => {
                gameMode = 'training';
                createTargets(); // Spawn targets for training
                startGame();
            });

            btnZombies.addEventListener('click', () => {
                mainMenu.classList.add('hidden');
                zombieConfigDiv.classList.remove('hidden');
                zombieConfigDiv.style.display = 'flex';
            });

            btnBack.addEventListener('click', () => {
                zombieConfigDiv.classList.add('hidden');
                zombieConfigDiv.style.display = 'none';
                mainMenu.classList.remove('hidden');
            });

            // Config Sliders
            const cfgCount = document.getElementById('cfg-count');
            const valCount = document.getElementById('val-count');
            cfgCount.addEventListener('input', () => { 
                zombieConfig.count = parseInt(cfgCount.value); 
                valCount.innerText = zombieConfig.count; 
            });

            const cfgSpeed = document.getElementById('cfg-speed');
            const valSpeed = document.getElementById('val-speed');
            cfgSpeed.addEventListener('input', () => { 
                zombieConfig.speed = parseInt(cfgSpeed.value); 
                valSpeed.innerText = zombieConfig.speed; 
            });
            
            const cfgRate = document.getElementById('cfg-rate');
            const valRate = document.getElementById('val-rate');
            cfgRate.addEventListener('input', () => { 
                zombieConfig.rate = parseInt(cfgRate.value); 
                valRate.innerText = zombieConfig.rate + 'ms'; 
            });

            btnStartZombies.addEventListener('click', () => {
                gameMode = 'zombies';
                startGame();
            });

            function startGame() {
                startScreen.style.display = 'none';
                
                // HUD logic
                if (gameMode === 'zombies') {
                    zombieHud.classList.remove('hidden');
                    zombieHud.style.display = 'block';
                    // Reset player health
                    playerHealth = 100;
                    document.getElementById('player-health').innerText = "100";
                    startWave(1);
                }

                // Check if mobile (screen width)
                if (window.innerWidth < 768) {
                    mobileControls.classList.remove('hidden');
                    mobileControls.style.display = 'block';
                    document.getElementById('ammo-display').style.display = 'block';
                } else {
                    controls.lock();
                }
            }

            controls.addEventListener('lock', () => {
                startScreen.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                // If on PC, maybe show pause menu. For now, just let them click to resume
                if (window.innerWidth >= 768) {
                    // Only show menu if we want to pause, for now simplify by just keeping mouse loose until click
                    // But usually we show a 'Click to Resume' or the menu.
                    // Let's just show the menu if the game hasn't really started, but here the menu is main menu.
                    // We'll leave it hidden and let click re-lock.
                    // Actually, if we want to quit/pause, we need a way. 
                    // For now, assume single session.
                    if (gameMode === 'none') startScreen.style.display = 'flex';
                }
            });

            // Re-lock on click if game started
            document.addEventListener('click', () => {
                if (gameMode !== 'none' && !controls.isLocked && window.innerWidth >= 768) {
                    controls.lock();
                }
            });

            scene.add(controls.getObject());

            // Key inputs
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump) velocity.y += config.jumpForce; canJump = false; break;
                    case 'KeyF': startInspect(); break;
                    case 'Digit1': switchWeapon(0); break;
                    case 'Digit2': switchWeapon(1); break;
                    case 'Digit3': switchWeapon(2); break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => {
                if (window.innerWidth >= 768 && controls.isLocked) {
                    startShooting();
                }
            });
            document.addEventListener('mouseup', stopShooting);

            // Mobile Inputs
            setupMobileControls();

            // 5. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
            
            raycaster = new THREE.Raycaster();
        }

        function createTargets() {
            const targetGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            const targetMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            
            // Create a few standup targets
            for(let i=0; i<6; i++) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5), new THREE.MeshStandardMaterial({color: 0x555555}));
                const target = new THREE.Mesh(targetGeo, targetMat);
                
                target.rotation.x = Math.PI / 2;
                target.position.y = 0.75;
                pole.add(target);
                
                pole.position.set(
                    (Math.random() - 0.5) * 35,
                    0.75,
                    (Math.random() - 0.5) * 35
                );
                
                // Don't spawn too close
                if (pole.position.length() < 5) pole.position.z -= 10;
                
                pole.userData = { isTarget: true, health: 100 };
                scene.add(pole);
                targets.push(pole);
            }
        }

        // --- Zombie System ---
        function createZombie(spawnPos) {
            const zombieGroup = new THREE.Group();
            zombieGroup.position.copy(spawnPos);
            
            // Material
            const skinMat = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.8 }); // Olive Drab
            const shirtMat = new THREE.MeshStandardMaterial({ color: 0x4B3621, roughness: 0.9 }); // Dark dirt color
            const pantMat = new THREE.MeshStandardMaterial({ color: 0x2F4F4F, roughness: 0.9 }); // Dark Slate

            // Legs
            const legGeo = new THREE.BoxGeometry(0.25, 0.8, 0.3);
            const leftLeg = new THREE.Mesh(legGeo, pantMat);
            leftLeg.position.set(-0.2, 0.4, 0);
            zombieGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, pantMat);
            rightLeg.position.set(0.2, 0.4, 0);
            zombieGroup.add(rightLeg);

            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.7, 0.8, 0.4);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.set(0, 1.2, 0);
            zombieGroup.add(torso);

            // Head
            const headGeo = new THREE.BoxGeometry(0.4, 0.5, 0.4);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.set(0, 1.85, 0);
            zombieGroup.add(head);
            
            // Eyes
            const eyeGeo = new THREE.BoxGeometry(0.08, 0.08, 0.05);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Glowing red eyes
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.1, 1.9, 0.2);
            zombieGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.1, 1.9, 0.2);
            zombieGroup.add(rightEye);

            // Arms (Outstretched)
            const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.25);
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 1.4, 0.3);
            leftArm.rotation.x = -Math.PI / 2.2; // Pointing forward
            leftArm.rotation.z = 0.1;
            zombieGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 1.4, 0.3);
            rightArm.rotation.x = -Math.PI / 2.2;
            rightArm.rotation.z = -0.1;
            zombieGroup.add(rightArm);

            // Logic data
            zombieGroup.userData = { 
                isZombie: true, 
                health: 100,
                speed: zombieConfig.speed * 0.05 // Base speed multiplier
            };

            scene.add(zombieGroup);
            zombies.push(zombieGroup);
            
            // Also add to targets so bullets hit them
            targets.push(zombieGroup);
        }

        function startWave(num) {
            waveNum = num;
            waveInProgress = true;
            document.getElementById('wave-num').innerText = waveNum;
            zombiesSpawnedInWave = 0;
            zombiesRemaining = zombieConfig.count + (waveNum - 1) * 2; // Increase count per wave slightly
            // Update global config count effectively for this wave? No, let's keep base config and scale here
            let totalToSpawn = zombieConfig.count + (waveNum - 1) * 2;
            
            // Fix: Logic was relying on config.count for loop limit.
            // Let's store current wave total.
            zombieConfig.currentWaveTotal = totalToSpawn;
            zombiesRemaining = totalToSpawn;
            
            document.getElementById('zombie-count').innerText = zombiesRemaining;
            
            // Clear old zombies
            zombies.forEach(z => scene.remove(z));
            zombies.length = 0;
            
            // Filter targets
            for(let i = targets.length - 1; i >= 0; i--) {
                if(targets[i].userData.isZombie) {
                    targets.splice(i, 1);
                }
            }
        }

        function updateZombies(delta, time) {
            if (!waveInProgress) return;
            
            // Spawning
            if (zombiesSpawnedInWave < zombieConfig.currentWaveTotal) {
                if (time - lastZombieSpawnTime > zombieConfig.rate) {
                    lastZombieSpawnTime = time;
                    zombiesSpawnedInWave++;
                    
                    // Spawn logic
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 40; // Spawn further out
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius;
                    createZombie(new THREE.Vector3(x, 0, z));
                }
            } else if (zombies.length === 0 && playerHealth > 0) {
                 // Wave cleared
                 waveInProgress = false;
                 
                 // Visual feedback
                 const hud = document.getElementById('zombie-hud');
                 const originalText = hud.innerHTML;
                 hud.innerHTML = "<div class='text-4xl text-green-400 text-center mt-4'>WAVE COMPLETE</div>";
                 
                 setTimeout(() => {
                     hud.innerHTML = originalText;
                     // Restore Health values to DOM because innerHTML wiped them
                     document.getElementById('player-health').innerText = Math.floor(playerHealth);
                     startWave(waveNum + 1);
                 }, 3000); 
            }

            // Movement & Collision
            const playerPos = controls.getObject().position;
            
            for (let i = zombies.length - 1; i >= 0; i--) {
                const z = zombies[i];
                
                // Move towards player
                const dir = new THREE.Vector3().subVectors(playerPos, z.position).setY(0).normalize();
                
                // Rotation (Look at player)
                z.lookAt(playerPos.x, z.position.y, playerPos.z);
                
                // Move
                z.position.addScaledVector(dir, z.userData.speed * delta * 50); // Speed scaling
                
                // Simple bobbing animation
                z.position.y = Math.abs(Math.sin(time * 0.01)) * 0.1;

                // Check collision with player
                const dist = z.position.distanceTo(playerPos);
                if (dist < 1.5) {
                    // Attack
                    if (playerHealth > 0) {
                        playerHealth -= 0.5; // Damage per frame close contact
                        document.getElementById('player-health').innerText = Math.floor(playerHealth);
                        if (playerHealth <= 0) {
                            // Game Over
                            document.getElementById('player-health').innerText = "DEAD";
                            // Show Game Over Screen logic?
                            alert("GAME OVER! Wave: " + waveNum);
                            location.reload(); 
                        }
                    }
                }
            }
        }

        function setupMobileControls() {
            const joystickZone = document.getElementById('joystick-zone');
            const joystickKnob = document.getElementById('joystick-knob');
            const lookZone = document.getElementById('look-zone');
            const btnShoot = document.getElementById('btn-shoot');
            const btnSwitch = document.getElementById('btn-switch');
            const btnInspect = document.getElementById('btn-inspect');
            
            // Inspect Button
            btnInspect.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                startInspect();
            });

            // Switch Button
            btnSwitch.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const nextIdx = (currentWeaponIdx + 1) % weapons.length;
                switchWeapon(nextIdx);
            });

            // Shoot Button
            btnShoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startShooting();
            });
            btnShoot.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopShooting();
            });

            // Joystick Logic
            let joyStartX = 0;
            let joyStartY = 0;
            let joyDragging = false;
            
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joyDragging = true;
                const touch = e.touches[0];
                const rect = joystickZone.getBoundingClientRect();
                joyStartX = rect.left + rect.width / 2;
                joyStartY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            joystickZone.addEventListener('touchmove', (e) => {
                if(!joyDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            const endJoy = (e) => {
                e.preventDefault();
                joyDragging = false;
                touchMove = { x: 0, y: 0 };
                joystickKnob.style.transform = `translate(-50%, -50%)`;
                moveForward = moveBackward = moveLeft = moveRight = false;
            };
            joystickZone.addEventListener('touchend', endJoy);
            
            function updateJoystick(x, y) {
                const maxDist = 35;
                let dx = x - joyStartX;
                let dy = y - joyStartY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }
                
                joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Normalize input -1 to 1
                touchMove.x = dx / maxDist;
                touchMove.y = dy / maxDist;
                
                // Update movement flags based on joystick
                moveForward = touchMove.y < -0.3;
                moveBackward = touchMove.y > 0.3;
                moveLeft = touchMove.x < -0.3;
                moveRight = touchMove.x > 0.3;
            }
            
            // Look Control (Right side of screen)
            let lastTouchX = 0;
            let lastTouchY = 0;
            
            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            });
            
            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                const deltaX = touchX - lastTouchX;
                const deltaY = touchY - lastTouchY;
                
                // Yaw
                controls.getObject().rotation.y -= deltaX * config.touchLookSensitivity;
                
                // Pitch
                camera.rotation.x -= deltaY * config.touchLookSensitivity;
                camera.rotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.rotation.x));
                
                lastTouchX = touchX;
                lastTouchY = touchY;
            });
        }

        // --- Game Functions ---
        function switchWeapon(index) {
            isInspecting = false; // Cancel inspect on switch
            currentWeaponIdx = index;
            weapons.forEach((w, i) => {
                w.mesh.visible = (i === index);
            });
            document.getElementById('weapon-name').innerText = weapons[index].name;
            
            // Animation reset
            if(weapons[index].mesh) {
                weapons[index].mesh.rotation.x = 0;
            }
        }

        function startInspect() {
            if (!isInspecting) {
                isInspecting = true;
                inspectStartTime = performance.now();
            }
        }

        function startShooting() {
            isShooting = true;
            isInspecting = false; // Cancel inspect on shoot
            
            // Reset inspect rotations immediately
            const w = weapons[currentWeaponIdx];
            if (w && w.mesh) {
                w.mesh.rotation.y = 0;
                if(w.type !== 'melee') w.mesh.rotation.z = 0;
                // Melee has specific rotation, reset logic in animate or stopShooting handles recoil, 
                // but inspect rotates base. We need to ensure base rotation is clean.
                // For simplicity, animate() handles idle/inspect loop resets.
            }
        }

        function stopShooting() {
            isShooting = false;
            // Reset recoil visual
            const w = weapons[currentWeaponIdx];
            if (w && w.mesh) {
                if (w.type === 'gun') w.mesh.position.z = -0.5; // Reset position
                if (w.type === 'melee') w.mesh.rotation.x = 0.2; // Reset rotation
            }
        }

        function fireWeapon(time) {
            const weapon = weapons[currentWeaponIdx];
            if (time - lastShootTime < weapon.fireRate) return;
            
            lastShootTime = time;
            
            // Recoil Animation
            if (weapon.type === 'gun') {
                weapon.mesh.position.z = -0.3; // Kick back
                setTimeout(() => { weapon.mesh.position.z = -0.5; }, 100);
                
                // Create bullet projectile visual
                createBullet();
            } else {
                // Knife swing
                weapon.mesh.rotation.x = -0.5; // Swing down
                setTimeout(() => { weapon.mesh.rotation.x = 0.2; }, 150);
            }
            
            // Raycast Hit logic
            const rayOrigin = new THREE.Vector3();
            const rayDir = new THREE.Vector3();
            camera.getWorldPosition(rayOrigin);
            camera.getWorldDirection(rayDir);
            
            raycaster.set(rayOrigin, rayDir);
            
            // Check targets
            const intersects = raycaster.intersectObjects(targets, true); // Recursive for children
            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                // Find parent pole which has userData
                let parent = hitObj;
                while(parent.parent && parent.parent !== scene && !parent.userData.isTarget && !parent.userData.isZombie) {
                    parent = parent.parent;
                }
                
                if (parent.userData.isTarget || parent.userData.isZombie) {
                    // Hit Effect
                    hitFeedback(intersects[0].point, 0x00ff00);
                    
                    parent.userData.health -= weapon.damage;
                    
                    if (parent.userData.health <= 0) {
                        if (parent.userData.isZombie) {
                             // Kill Zombie
                             scene.remove(parent);
                             const idx = zombies.indexOf(parent);
                             if(idx > -1) zombies.splice(idx, 1);
                             
                             const tIdx = targets.indexOf(parent);
                             if(tIdx > -1) targets.splice(tIdx, 1);
                             
                             zombiesRemaining = Math.max(0, zombiesRemaining - 1);
                             document.getElementById('zombie-count').innerText = zombiesRemaining;
                        } else {
                             // Respawn target
                             parent.position.set(
                                 (Math.random() - 0.5) * 35,
                                 0.75,
                                 (Math.random() - 0.5) * 35
                             );
                             parent.userData.health = 100;
                        }
                    }
                }
            } else {
                // Hit wall?
                const wallHits = raycaster.intersectObjects(objects);
                if (wallHits.length > 0) {
                     hitFeedback(wallHits[0].point, 0x555555);
                }
            }
        }
        
        function createBullet() {
            // Simple yellow line tracer
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const points = [];
            const start = new THREE.Vector3();
            const end = new THREE.Vector3();
            
            // Offset slightly to right/down to match gun barrel
            // We need world coordinates of gun barrel end.
            // Simplified: just start from camera forward slightly
            
            camera.getWorldPosition(start);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            // Offset bullet start relative to camera right/down
            const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
            start.addScaledVector(dir, 0.5);
            start.addScaledVector(right, 0.2); 
            start.y -= 0.1;

            end.copy(start).addScaledVector(dir, 50); // Tracer length
            
            points.push(start);
            points.push(end);
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Remove after short time
            setTimeout(() => {
                scene.remove(line);
                geometry.dispose();
                material.dispose();
            }, 50);
        }

        function hitFeedback(pos, color=0xff0000) {
            const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const particleMat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<3; i++) {
                const p = new THREE.Mesh(particleGeo, particleMat);
                p.position.copy(pos);
                p.position.x += (Math.random() - 0.5) * 0.5;
                p.position.y += (Math.random() - 0.5) * 0.5;
                p.position.z += (Math.random() - 0.5) * 0.5;
                scene.add(p);
                
                setTimeout(() => {
                    scene.remove(p);
                }, 200 + Math.random() * 300);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // Physics / Movement
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 10.0 * delta; // 100.0 = mass
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // consistent speed in all directions

            // Adjusted speed multiplier for slower movement
            const speedMultiplier = config.speed * 40.0; // 5.0 * 40 = 200 (was 400 with speed 10)
            if (moveForward || moveBackward) velocity.z -= direction.z * speedMultiplier * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speedMultiplier * delta;

            // Apply movement (PointerLockControls handles the object position, but we need to update it manually if not using its move methods correctly for physics)
            // Three.js PointerLockControls uses .moveRight() and .moveForward() which depend on camera Y-rotation only.
            
            const controlObject = controls.getObject();
            
            // X/Z Movement
            // Apply speed scaling directly to velocity application if needed, 
            // but we changed force above. However, the damping is constant (10.0), so lower force = lower max speed.
            controlObject.translateX(velocity.x * delta);
            controlObject.translateZ(velocity.z * delta);
            
            // Y Movement (Jump/Gravity)
            controlObject.position.y += (velocity.y * delta); // * 0.1 scale? No, velocity is large.
            
            // Floor Collision
            if (controlObject.position.y < config.playerHeight) {
                velocity.y = 0;
                controlObject.position.y = config.playerHeight;
                canJump = true;
            }

            // Wall Collision (Simple AABB)
            const playerPos = controlObject.position.clone();
            const playerRadius = 0.5; // Hitbox radius

            for (const obj of objects) {
                // Create bounding box for the object if not cached (simple box assumption)
                const box = new THREE.Box3().setFromObject(obj);
                
                // Check if player is inside the expanded box (box + radius)
                if (playerPos.x > box.min.x - playerRadius && playerPos.x < box.max.x + playerRadius &&
                    playerPos.z > box.min.z - playerRadius && playerPos.z < box.max.z + playerRadius) {
                    
                    // Determine overlap and push back
                    // This is a simple separation logic
                    const dx = Math.max(box.min.x - playerRadius - playerPos.x, playerPos.x - (box.max.x + playerRadius));
                    const dz = Math.max(box.min.z - playerRadius - playerPos.z, playerPos.z - (box.max.z + playerRadius));

                    if (Math.abs(dx) < Math.abs(dz)) {
                         // Closer to x edge
                         if (playerPos.x < box.min.x) controlObject.position.x = box.min.x - playerRadius;
                         else controlObject.position.x = box.max.x + playerRadius;
                    } else {
                         // Closer to z edge
                         if (playerPos.z < box.min.z) controlObject.position.z = box.min.z - playerRadius;
                         else controlObject.position.z = box.max.z + playerRadius;
                    }
                }
            }
            
            // Game Mode Logic
            if (gameMode === 'zombies') {
                updateZombies(delta, time);
            }

            // Shooting
            if (isShooting) {
                fireWeapon(time);
            }

            // Weapon Animation (Bobbing or Inspect)
            if (isInspecting) {
                const inspectElapsed = time - inspectStartTime;
                const duration = 2000; // 2 seconds inspect
                const w = weapons[currentWeaponIdx];

                if (inspectElapsed < duration) {
                    // Simple inspect animation: rotate weapon to look at side
                    const progress = inspectElapsed / duration;
                    const angle = Math.sin(progress * Math.PI) * 0.5; // -0.5 to 0.5 rad
                    
                    if (w && w.mesh) {
                        // Different axis based on weapon type/preference
                        // Rotate around Y and Z to show side
                        w.mesh.rotation.y = Math.sin(progress * Math.PI) * 1.5; 
                        w.mesh.rotation.z = Math.sin(progress * Math.PI) * 0.5;
                        w.mesh.position.x = 0.3 - Math.sin(progress * Math.PI) * 0.2; // Move slightly center
                    }
                } else {
                    isInspecting = false;
                    // Reset
                    if (w && w.mesh) {
                        w.mesh.rotation.y = 0;
                        w.mesh.rotation.z = 0;
                        // Initial positions
                        if (currentWeaponIdx === 0) w.mesh.position.set(0.3, -0.4, -0.5); // AK
                        else if (currentWeaponIdx === 1) { 
                             w.mesh.position.set(0.3, -0.4, -0.4); 
                             w.mesh.rotation.set(0.2, -0.1, 0); // Knife default
                        }
                        else if (currentWeaponIdx === 2) {
                             w.mesh.position.set(0.3, -0.35, -0.4); 
                             w.mesh.rotation.set(0, 0, 0); // CZ reset (handle rotation is internal)
                        }
                    }
                }
            } else if (moveForward || moveBackward || moveLeft || moveRight) {
                // Bobbing
                weaponContainer.position.y = Math.sin(time / 150) * 0.02;
                weaponContainer.position.x = Math.sin(time / 300) * 0.02;
                
                // Ensure individual weapon rotations are reset if not inspecting
                const w = weapons[currentWeaponIdx];
                if (w && w.mesh) {
                     // Keep default rotations
                     if (currentWeaponIdx === 1) { // Knife special default
                        w.mesh.rotation.x = 0.2; 
                        w.mesh.rotation.y = -0.1;
                     } else {
                        w.mesh.rotation.y = 0;
                        w.mesh.rotation.z = 0;
                     }
                }
            } else {
                 // Idle breathing
                 weaponContainer.position.y = Math.sin(time / 1000) * 0.005;
                 weaponContainer.position.x = 0;
                 
                 // Ensure reset
                 const w = weapons[currentWeaponIdx];
                 if (w && w.mesh && !isShooting) {
                     if (currentWeaponIdx === 1) { // Knife
                        w.mesh.rotation.x = 0.2; 
                        w.mesh.rotation.y = -0.1;
                        w.mesh.rotation.z = 0;
                     } else {
                        w.mesh.rotation.y = 0;
                        w.mesh.rotation.z = 0;
                     }
                 }
            }

            renderer.render(scene, camera);
            prevTime = time;
        }
    </script>
</body>
</html>