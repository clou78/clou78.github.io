<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terraria HTML5 Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; user-select: none; background: #333; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; image-rendering: pixelated; cursor: crosshair; }
        .pixel-art { image-rendering: pixelated; }
        
        /* Mobile Controls Styling */
        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.4); }

        /* Inventory Slot */
        .inv-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .inv-slot.active { border-color: #fbbf24; background: rgba(251, 191, 36, 0.2); }
        .inv-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: white; }

        /* Inventory Modal */
        #inventory-modal {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 60;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        .inv-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-auto-rows: min-content;
            gap: 4px;
            background: #444;
            padding: 8px;
            border: 2px solid #888;
            max-width: 95%;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 50px;
            right: 10px;
            border: 2px solid #fff;
            background: rgba(0,0,0,0.5);
            display: none; /* Hidden by default, toggle with M */
            z-index: 45;
        }
        
        @media (max-width: 600px) {
            .inv-grid { grid-template-columns: repeat(6, 1fr); }
            #minimap-container { top: 60px; right: 10px; transform: scale(0.8); transform-origin: top right; }
        }
    </style>
</head>
<body>

    <!-- Inventory Modal -->
    <div id="inventory-modal">
        <h2 class="text-2xl font-bold mb-2">Инвентарь</h2>
        <div class="inv-grid" id="full-inventory">
            <!-- Slots generated by JS -->
        </div>
        
        <div class="flex gap-4 mt-4 items-center">
            <button onclick="changeInvPage(-1)" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 border border-gray-500 font-bold">&lt;</button>
            <span id="page-indicator" class="font-bold text-xl">1 / 2</span>
            <button onclick="changeInvPage(1)" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 border border-gray-500 font-bold">&gt;</button>
        </div>

        <button onclick="toggleInventory()" class="mt-4 px-6 py-2 bg-red-600 hover:bg-red-500 border border-red-400 font-bold">Закрыть</button>
        <p class="mt-2 text-gray-400 text-sm">Нажми на предмет, чтобы переместить в выбранный слот</p>
    </div>

    <!-- Main Menu -->
    <div id="main-menu" class="absolute inset-0 flex flex-col items-center justify-center bg-[url('https://wallpaperaccess.com/full/186532.jpg')] bg-cover bg-center z-50">
        <div class="absolute inset-0 bg-black/50"></div>
        <div class="relative z-10 flex flex-col gap-4 text-center items-center max-w-md w-full p-6">
            <h1 class="text-6xl font-bold text-green-500 drop-shadow-[0_4px_4px_rgba(0,0,0,1)] mb-8 tracking-tighter">TERRARIA-LITE</h1>
            
            <button onclick="showCreateWorld()" class="w-64 py-3 bg-green-700 hover:bg-green-600 border-2 border-green-400 text-white font-bold text-xl shadow-lg transition transform hover:scale-105">
                Одиночная Игра
            </button>
            
            <button onclick="openModsMenu()" class="w-64 py-3 bg-purple-700 hover:bg-purple-600 border-2 border-purple-400 text-white font-bold text-xl shadow-lg transition transform hover:scale-105">
                Моды / Читы
            </button>

            <div class="flex gap-2 w-64">
                 <label class="flex-1 py-3 bg-blue-700 hover:bg-blue-600 border-2 border-blue-400 text-white font-bold text-center cursor-pointer shadow-lg">
                    Загрузить Мир (JSON)
                    <input type="file" id="load-file" class="hidden" accept=".json" onchange="loadWorldFromFile(this)">
                </label>
            </div>
        </div>
    </div>

    <!-- Mods Menu -->
    <div id="mods-menu" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-50 text-white">
        <div class="flex flex-col gap-4 w-full max-w-md p-6 border-2 border-purple-500 bg-gray-800 h-3/4 overflow-y-auto">
            <h2 class="text-2xl font-bold text-center mb-4 text-purple-400 sticky top-0 bg-gray-800 pb-2 border-b border-purple-500/30">Менеджер Модов</h2>
            
            <h3 class="text-lg font-bold text-yellow-400 uppercase tracking-widest mb-1">Активные Читы</h3>
            <div class="flex flex-col gap-2">
                <div class="flex items-center gap-3 p-2 bg-gray-900/80 border border-gray-700 rounded hover:bg-gray-700 transition">
                    <input type="checkbox" id="mod-fly" class="w-5 h-5 accent-purple-500" onchange="toggleMod('fly')">
                    <label for="mod-fly" class="flex-1 font-bold cursor-pointer">Полет (God Mode)</label>
                </div>

                <div class="flex items-center gap-3 p-2 bg-gray-900/80 border border-gray-700 rounded hover:bg-gray-700 transition">
                    <input type="checkbox" id="mod-speed" class="w-5 h-5 accent-purple-500" onchange="toggleMod('speed')">
                    <label for="mod-speed" class="flex-1 font-bold cursor-pointer">Супер Скорость</label>
                </div>

                <div class="flex items-center gap-3 p-2 bg-gray-900/80 border border-gray-700 rounded hover:bg-gray-700 transition">
                    <input type="checkbox" id="mod-noclip" class="w-5 h-5 accent-purple-500" onchange="toggleMod('noclip')">
                    <label for="mod-noclip" class="flex-1 font-bold cursor-pointer">Noclip (Сквозь стены)</label>
                </div>
            </div>

            <h3 class="text-lg font-bold text-blue-400 uppercase tracking-widest mt-6 mb-1">Магазин Модов</h3>
            <div class="flex flex-col gap-2" id="mod-store-list">
                
                <!-- Mod Item 1 -->
                <div class="flex items-center justify-between p-3 bg-gray-900 border border-gray-600 rounded">
                    <div class="flex flex-col">
                        <span class="font-bold text-white">Лунная Гравитация</span>
                        <span class="text-xs text-gray-400">Прыжки выше, падение медленнее</span>
                    </div>
                    <button onclick="installMod('low_gravity', this)" class="px-3 py-1 bg-green-700 hover:bg-green-600 text-xs font-bold rounded border border-green-500 transition">СКАЧАТЬ</button>
                </div>

                <!-- Mod Item 2 -->
                <div class="flex items-center justify-between p-3 bg-gray-900 border border-gray-600 rounded">
                    <div class="flex flex-col">
                        <span class="font-bold text-white">Длинные Руки</span>
                        <span class="text-xs text-gray-400">Ломай блоки издалека (15 блоков)</span>
                    </div>
                    <button onclick="installMod('long_reach', this)" class="px-3 py-1 bg-green-700 hover:bg-green-600 text-xs font-bold rounded border border-green-500 transition">СКАЧАТЬ</button>
                </div>

                 <!-- Mod Item 3 -->
                 <div class="flex items-center justify-between p-3 bg-gray-900 border border-gray-600 rounded">
                    <div class="flex flex-col">
                        <span class="font-bold text-white">Гига-Прыжок</span>
                        <span class="text-xs text-gray-400">Прыжок x3 силы</span>
                    </div>
                    <button onclick="installMod('mega_jump', this)" class="px-3 py-1 bg-green-700 hover:bg-green-600 text-xs font-bold rounded border border-green-500 transition">СКАЧАТЬ</button>
                </div>

            </div>

            <button onclick="closeModsMenu()" class="mt-6 py-3 bg-red-600 hover:bg-red-500 font-bold border-2 border-red-400 rounded shadow-lg sticky bottom-0">Назад</button>
        </div>
    </div>

    <!-- Create World Menu -->
    <div id="create-menu" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-50 text-white">
        <div class="flex flex-col gap-4 w-full max-w-sm p-6 border-2 border-gray-600 bg-gray-800">
            <h2 class="text-2xl font-bold text-center mb-4">Создать Мир</h2>
            
            <div class="flex flex-col gap-1">
                <label>Название Мира</label>
                <input type="text" id="world-name" value="World 1" class="p-2 bg-gray-900 border border-gray-600 text-white">
            </div>

            <div class="flex flex-col gap-1">
                <label>Сид (Seed)</label>
                <input type="text" id="world-seed" placeholder="Оставьте пустым для случайного" class="p-2 bg-gray-900 border border-gray-600 text-white">
            </div>

            <div class="flex flex-col gap-1">
                <label>Режим</label>
                <div class="flex gap-2">
                    <button id="btn-classic" onclick="setMode('Classic')" class="flex-1 py-2 bg-green-700 border border-green-500">Классика</button>
                    <button id="btn-adventure" onclick="setMode('Adventure')" class="flex-1 py-2 bg-gray-700 border border-gray-500">Приключение</button>
                </div>
            </div>

            <div class="flex gap-2 mt-4">
                <button onclick="startGame()" class="flex-1 py-3 bg-green-600 hover:bg-green-500 font-bold">Играть</button>
                <button onclick="showMainMenu()" class="flex-1 py-3 bg-red-600 hover:bg-red-500 font-bold">Назад</button>
            </div>
        </div>
    </div>

    <!-- Game UI -->
    <div id="game-ui" class="hidden absolute inset-0 z-40 pointer-events-none">
        <!-- Top Bar -->
        <div class="absolute top-2 left-2 right-2 flex justify-between pointer-events-auto">
            <div class="flex gap-2">
                <button onclick="saveWorld()" class="px-2 py-1 bg-blue-600 text-xs border border-blue-400 text-white font-bold">Сохранить (JSON)</button>
                <button onclick="quitGame()" class="px-2 py-1 bg-red-600 text-xs border border-red-400 text-white font-bold">Выйти</button>
                <button onclick="toggleInventory()" class="px-2 py-1 bg-purple-600 text-xs border border-purple-400 text-white font-bold">Инв</button>
                <button onclick="toggleMap()" class="px-2 py-1 bg-yellow-600 text-xs border border-yellow-400 text-white font-bold">Карта</button>
                <button onclick="openModsMenu()" class="px-2 py-1 bg-pink-600 text-xs border border-pink-400 text-white font-bold">Читы</button>
            </div>
            <div class="text-white font-bold drop-shadow-md text-right">
                <div id="fps-counter">FPS: 60</div>
                <div id="coords">X: 0 Y: 0</div>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="200" height="100"></canvas>
        </div>

        <!-- Inventory / Hotbar -->
        <div class="absolute top-10 left-1/2 transform -translate-x-1/2 flex gap-1 pointer-events-auto" id="hotbar">
            <!-- Slots generated by JS -->
        </div>

        <!-- Mobile Controls -->
        <div class="absolute bottom-4 left-4 w-32 h-32 pointer-events-auto md:hidden touch-manipulation">
            <!-- D-Pad visual -->
            <div class="relative w-full h-full bg-white/10 rounded-full backdrop-blur-sm border border-white/30" id="joystick-zone">
                <div id="joystick-knob" class="absolute w-12 h-12 bg-white/50 rounded-full top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 shadow-lg"></div>
            </div>
        </div>

        <div class="absolute bottom-16 right-4 flex gap-4 pointer-events-auto md:hidden">
            <button id="btn-mode" onclick="toggleMobileAction()" class="control-btn w-16 h-16 bg-yellow-500/30 text-xs font-bold">MODE: MINE</button>
            <button id="btn-jump" class="control-btn w-16 h-16 bg-blue-500/30">JUMP</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- GAME CONFIG & CONSTANTS ---
        const TILE_SIZE = 32;
        const CHUNK_WIDTH = 16; 
        const WORLD_WIDTH = 200; // Small world for performance/MVP
        const WORLD_HEIGHT = 100;
        
        const BLOCKS = {
            AIR: 0,
            DIRT: 1,
            GRASS: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            BRICK: 6,
            PLANK: 7,
            SAND: 8,
            GLASS: 9,
            COAL_ORE: 10,
            GOLD_ORE: 11,
            DIAMOND_ORE: 12,
            TNT: 13,
            FLOWER: 14,
            CACTUS: 15,
            STONE_BRICK: 16,
            MOSSY_STONE: 17,
            RED_SAND: 18,
            CLAY: 19,
            HARDENED_CLAY: 20,
            WOOL_RED: 21,
            WOOL_ORANGE: 22,
            WOOL_YELLOW: 23,
            WOOL_GREEN: 24,
            WOOL_CYAN: 25,
            WOOL_BLUE: 26,
            WOOL_PURPLE: 27,
            WOOL_PINK: 28,
            WOOL_BLACK: 29,
            WOOL_WHITE: 30,
            
            // Nature & Biomes
            MUD: 31, SNOW: 32, ICE: 33, ASH: 34, SILT: 35,
            JUNGLE_GRASS: 36, MUSHROOM_GRASS: 37, CORRUPT_GRASS: 38, CRIMSON_GRASS: 39, HALLOWED_GRASS: 40,
            EBONSTONE: 41, CRIMSTONE: 42, PEARLSTONE: 43, HELLSTONE: 44, OBSIDIAN: 45,

            // Ores & Metals
            ORE_COPPER: 46, ORE_IRON: 47, ORE_SILVER: 48, ORE_TUNGSTEN: 49, ORE_PLATINUM: 50,
            ORE_METEORITE: 51, ORE_DEMONITE: 52, ORE_CRIMTANE: 53,
            BLOCK_COPPER: 54, BLOCK_IRON: 55, BLOCK_SILVER: 56, BLOCK_GOLD: 57, BLOCK_PLATINUM: 58,

            // Woods
            WOOD_MAHOGANY: 60, WOOD_BOREAL: 61, WOOD_PALM: 62, WOOD_EBON: 63, WOOD_SHADE: 64, WOOD_PEARL: 65, WOOD_SPOOKY: 66, WOOD_DYNASTY: 67,

            // Dungeon & Bricks
            BRICK_DUNGEON_BLUE: 70, BRICK_DUNGEON_GREEN: 71, BRICK_DUNGEON_PINK: 72,
            BRICK_HELLSTONE: 73, BRICK_OBSIDIAN: 74, BRICK_MUD: 75, BRICK_SNOW: 76,
            
            // Gems (Blocks)
            GEM_RUBY: 80, GEM_SAPPHIRE: 81, GEM_EMERALD: 82, GEM_TOPAZ: 83, GEM_AMETHYST: 84, GEM_DIAMOND: 85, GEM_AMBER: 86,

            // Stained Glass
            GLASS_RED: 90, GLASS_GREEN: 91, GLASS_BLUE: 92, GLASS_YELLOW: 93, GLASS_PURPLE: 94, GLASS_ORANGE: 95, GLASS_BLACK: 96,

            // Exotic / Misc
            CLOUD: 100, RAIN_CLOUD: 101, SUNPLATE: 102, ASPHALT: 103, FLESH_BLOCK: 104, SLIME_BLOCK: 105, 
            HONEY_BLOCK: 106, CRISPY_HONEY: 107, HAY: 108, PUMPKIN: 109,
            
            // More Colors/Building
            TEAM_BLOCK_RED: 110, TEAM_BLOCK_GREEN: 111, TEAM_BLOCK_BLUE: 112, TEAM_BLOCK_YELLOW: 113, TEAM_BLOCK_PINK: 114,
            
            BEDROCK: 999
        };

        const BLOCK_COLORS = {
            [BLOCKS.DIRT]: '#5d4037', [BLOCKS.GRASS]: '#388e3c', [BLOCKS.STONE]: '#757575',
            [BLOCKS.WOOD]: '#795548', [BLOCKS.LEAVES]: '#2e7d32', [BLOCKS.BRICK]: '#8d6e63',
            [BLOCKS.PLANK]: '#d7ccc8', [BLOCKS.SAND]: '#fdd835', [BLOCKS.GLASS]: 'rgba(135, 206, 250, 0.5)',
            [BLOCKS.COAL_ORE]: '#424242', [BLOCKS.GOLD_ORE]: '#ffb300', [BLOCKS.DIAMOND_ORE]: '#00e5ff',
            [BLOCKS.TNT]: '#e53935', [BLOCKS.FLOWER]: '#e91e63', [BLOCKS.CACTUS]: '#64dd17',
            [BLOCKS.STONE_BRICK]: '#616161', [BLOCKS.MOSSY_STONE]: '#4e6d45', [BLOCKS.RED_SAND]: '#d84315',
            [BLOCKS.CLAY]: '#9fa8da', [BLOCKS.HARDENED_CLAY]: '#d7ccc8',
            [BLOCKS.WOOL_RED]: '#f44336', [BLOCKS.WOOL_ORANGE]: '#ff9800', [BLOCKS.WOOL_YELLOW]: '#ffeb3b',
            [BLOCKS.WOOL_GREEN]: '#4caf50', [BLOCKS.WOOL_CYAN]: '#00bcd4', [BLOCKS.WOOL_BLUE]: '#2196f3',
            [BLOCKS.WOOL_PURPLE]: '#9c27b0', [BLOCKS.WOOL_PINK]: '#e91e63', [BLOCKS.WOOL_BLACK]: '#212121', [BLOCKS.WOOL_WHITE]: '#f5f5f5',

            // New Colors
            [BLOCKS.MUD]: '#3e2723', [BLOCKS.SNOW]: '#fffafa', [BLOCKS.ICE]: '#e1f5fe', [BLOCKS.ASH]: '#263238', [BLOCKS.SILT]: '#78909c',
            [BLOCKS.JUNGLE_GRASS]: '#64dd17', [BLOCKS.MUSHROOM_GRASS]: '#2979ff', [BLOCKS.CORRUPT_GRASS]: '#7b1fa2', [BLOCKS.CRIMSON_GRASS]: '#d32f2f', [BLOCKS.HALLOWED_GRASS]: '#00e676',
            [BLOCKS.EBONSTONE]: '#4a148c', [BLOCKS.CRIMSTONE]: '#b71c1c', [BLOCKS.PEARLSTONE]: '#f8bbd0', [BLOCKS.HELLSTONE]: '#bf360c', [BLOCKS.OBSIDIAN]: '#3e2723',

            [BLOCKS.ORE_COPPER]: '#ff5722', [BLOCKS.ORE_IRON]: '#a1887f', [BLOCKS.ORE_SILVER]: '#e0e0e0', [BLOCKS.ORE_TUNGSTEN]: '#5d4037', [BLOCKS.ORE_PLATINUM]: '#b0bec5',
            [BLOCKS.ORE_METEORITE]: '#3e2723', [BLOCKS.ORE_DEMONITE]: '#512da8', [BLOCKS.ORE_CRIMTANE]: '#d50000',
            [BLOCKS.BLOCK_COPPER]: '#ff8a65', [BLOCKS.BLOCK_IRON]: '#bcaaa4', [BLOCKS.BLOCK_SILVER]: '#eeeeee', [BLOCKS.BLOCK_GOLD]: '#ffca28', [BLOCKS.BLOCK_PLATINUM]: '#cfd8dc',

            [BLOCKS.WOOD_MAHOGANY]: '#5d4037', [BLOCKS.WOOD_BOREAL]: '#8d6e63', [BLOCKS.WOOD_PALM]: '#e65100', [BLOCKS.WOOD_EBON]: '#4a148c', 
            [BLOCKS.WOOD_SHADE]: '#607d8b', [BLOCKS.WOOD_PEARL]: '#fff9c4', [BLOCKS.WOOD_SPOOKY]: '#424242', [BLOCKS.WOOD_DYNASTY]: '#ffcc80',

            [BLOCKS.BRICK_DUNGEON_BLUE]: '#1a237e', [BLOCKS.BRICK_DUNGEON_GREEN]: '#1b5e20', [BLOCKS.BRICK_DUNGEON_PINK]: '#880e4f',
            [BLOCKS.BRICK_HELLSTONE]: '#d84315', [BLOCKS.BRICK_OBSIDIAN]: '#212121', [BLOCKS.BRICK_MUD]: '#5d4037', [BLOCKS.BRICK_SNOW]: '#eceff1',

            [BLOCKS.GEM_RUBY]: '#f44336', [BLOCKS.GEM_SAPPHIRE]: '#2196f3', [BLOCKS.GEM_EMERALD]: '#4caf50', [BLOCKS.GEM_TOPAZ]: '#ffeb3b',
            [BLOCKS.GEM_AMETHYST]: '#9c27b0', [BLOCKS.GEM_DIAMOND]: '#b3e5fc', [BLOCKS.GEM_AMBER]: '#ffb74d',

            [BLOCKS.GLASS_RED]: 'rgba(244, 67, 54, 0.6)', [BLOCKS.GLASS_GREEN]: 'rgba(76, 175, 80, 0.6)', [BLOCKS.GLASS_BLUE]: 'rgba(33, 150, 243, 0.6)',
            [BLOCKS.GLASS_YELLOW]: 'rgba(255, 235, 59, 0.6)', [BLOCKS.GLASS_PURPLE]: 'rgba(156, 39, 176, 0.6)', [BLOCKS.GLASS_ORANGE]: 'rgba(255, 152, 0, 0.6)', [BLOCKS.GLASS_BLACK]: 'rgba(0, 0, 0, 0.6)',

            [BLOCKS.CLOUD]: '#ffffff', [BLOCKS.RAIN_CLOUD]: '#616161', [BLOCKS.SUNPLATE]: '#fdd835', [BLOCKS.ASPHALT]: '#212121',
            [BLOCKS.FLESH_BLOCK]: '#e57373', [BLOCKS.SLIME_BLOCK]: '#42a5f5', [BLOCKS.HONEY_BLOCK]: '#ffb300', [BLOCKS.CRISPY_HONEY]: '#f57f17',
            [BLOCKS.HAY]: '#fff176', [BLOCKS.PUMPKIN]: '#ff6f00',
            
            [BLOCKS.TEAM_BLOCK_RED]: '#ff5252', [BLOCKS.TEAM_BLOCK_GREEN]: '#69f0ae', [BLOCKS.TEAM_BLOCK_BLUE]: '#448aff', 
            [BLOCKS.TEAM_BLOCK_YELLOW]: '#ffff00', [BLOCKS.TEAM_BLOCK_PINK]: '#ff4081',

            [BLOCKS.BEDROCK]: '#000000',
            99: '#000000' // Legacy Bedrock support for old saves
        };

        // --- STATE ---
        let canvas, ctx;
        let gameLoopId;
        let camera = { x: 0, y: 0 };
        let world = {
            name: "World",
            seed: 0,
            mode: 'Classic',
            width: WORLD_WIDTH,
            height: WORLD_HEIGHT,
            tiles: [], // 2D array [x][y]
        };
        let player = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            width: 20, height: 40,
            speed: 5,
            jumpForce: 10,
            grounded: false,
            inventory: [
                { id: BLOCKS.DIRT, count: 0 },
                { id: BLOCKS.STONE, count: 0 },
                { id: BLOCKS.WOOD, count: 0 },
                { id: BLOCKS.GRASS, count: 0 },
                { id: BLOCKS.LEAVES, count: 0 },
            ],
            selectedSlot: 0
        };
        
        const INVENTORY_SIZE = 450;
        const HOTBAR_SIZE = 8;
        const INV_PAGE_SIZE = 45; // 9 columns * 5 rows
        let currentInvPage = 0;

        // Inputs
        let keys = {};
        let mods = { 
            fly: false, 
            speed: false, 
            noclip: false,
            low_gravity: false,
            long_reach: false,
            mega_jump: false
        };
        let mouse = { x: 0, y: 0, leftDown: false, rightDown: false };
        let joystick = { active: false, dx: 0, dy: 0, originX: 0, originY: 0, pointerId: null };
        let mobileActionMode = 'MINE'; // 'MINE' or 'BUILD'
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- INITIALIZATION ---
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupInputs();
            updateHotbarUI();
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;
        }

        // --- MENU LOGIC ---
        let selectedMode = 'Classic';
        let gameRunning = false;

        function showCreateWorld() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('create-menu').classList.remove('hidden');
        }

        function openModsMenu() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('mods-menu').classList.remove('hidden');
        }

        function closeModsMenu() {
            document.getElementById('mods-menu').classList.add('hidden');
            if (gameRunning) {
                document.getElementById('game-ui').classList.remove('hidden');
            } else {
                document.getElementById('main-menu').classList.remove('hidden');
            }
        }

        function toggleMod(mod) {
            mods[mod] = !mods[mod];
        }

        function installMod(mod, btn) {
            if (mods[mod]) return; // Already installed
            
            let originalText = btn.innerText;
            btn.innerText = "ЗАГРУЗКА...";
            btn.className = "px-3 py-1 bg-gray-600 text-xs font-bold rounded border border-gray-500 cursor-wait";
            
            setTimeout(() => {
                mods[mod] = true;
                btn.innerText = "УСТАНОВЛЕНО";
                btn.className = "px-3 py-1 bg-blue-600 text-xs font-bold rounded border border-blue-400 cursor-default";
                btn.onclick = null; // Disable click
            }, 1000); // 1 second fake download
        }

        function showMainMenu() {
            gameRunning = false;
            document.getElementById('create-menu').classList.add('hidden');
            document.getElementById('mods-menu').classList.add('hidden');
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            cancelAnimationFrame(gameLoopId);
        }

        function setMode(mode) {
            selectedMode = mode;
            document.getElementById('btn-classic').className = mode === 'Classic' ? 
                "flex-1 py-2 bg-green-700 border border-green-500" : "flex-1 py-2 bg-gray-700 border border-gray-500";
            document.getElementById('btn-adventure').className = mode === 'Adventure' ? 
                "flex-1 py-2 bg-green-700 border border-green-500" : "flex-1 py-2 bg-gray-700 border border-gray-500";
        }

        function startGame(loadedWorld = null) {
            gameRunning = true;
            document.getElementById('create-menu').classList.add('hidden');
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            
            if (loadedWorld) {
                world = loadedWorld;
                // Ensure player object structure is robust if loaded from old version
                if (!world.player) resetPlayer();
                else {
                    player = world.player;
                    // Migrate Inventory if old save
                    if (player.inventory && player.inventory.length < INVENTORY_SIZE) {
                        while (player.inventory.length < INVENTORY_SIZE) {
                            player.inventory.push({ id: BLOCKS.AIR, count: 0 });
                        }
                    }
                }
            } else {
                let seedInput = document.getElementById('world-seed').value;
                let seed = seedInput ? stringToSeed(seedInput) : Math.floor(Math.random() * 100000);
                let name = document.getElementById('world-name').value || "New World";
                generateWorld(name, seed, selectedMode);
                resetPlayer();
            }

            // Start Loop
            lastTime = performance.now();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function toggleMobileAction() {
            mobileActionMode = mobileActionMode === 'MINE' ? 'BUILD' : 'MINE';
            document.getElementById('btn-mode').innerText = `MODE: ${mobileActionMode}`;
            document.getElementById('btn-mode').style.borderColor = mobileActionMode === 'MINE' ? 'red' : 'lime';
        }

        function resetPlayer() {
            player.x = world.width * TILE_SIZE / 2;
            player.y = 0;
            player.vx = 0;
            player.vy = 0;
            
            // Initialize Inventory
            player.inventory = [];
            for(let i=0; i<INVENTORY_SIZE; i++) player.inventory.push({id: BLOCKS.AIR, count: 0});

            if (world.mode === 'Adventure') {
                // Fill inventory with everything
                const allBlocks = Object.values(BLOCKS).filter(b => b !== BLOCKS.AIR && b !== BLOCKS.BEDROCK);
                
                allBlocks.forEach((b, i) => {
                    if (i < INVENTORY_SIZE) {
                        player.inventory[i] = { id: b, count: 999 };
                    }
                });
            } else {
                // Starter Kit for Classic
                player.inventory[0] = { id: BLOCKS.AIR, count: 0 };
            }

            updateHotbarUI();

            // Find ground
            let tx = Math.floor(player.x / TILE_SIZE);
            for (let y = 0; y < world.height; y++) {
                if (world.tiles[tx][y] !== BLOCKS.AIR) {
                    player.y = (y - 3) * TILE_SIZE;
                    break;
                }
            }
        }

        function quitGame() {
            showMainMenu();
        }

        // --- WORLD GENERATION ---
        function stringToSeed(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            return hash;
        }

        // Simple pseudo-random number generator
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        function generateWorld(name, seed, mode) {
            world.name = name;
            world.seed = seed;
            world.mode = mode;
            world.tiles = new Array(world.width).fill(0).map(() => new Array(world.height).fill(BLOCKS.AIR));

            const rand = mulberry32(seed);
            const noise = (x, freq) => Math.sin(x * freq + seed) * Math.cos(x * freq * 0.5 + seed); 

            const groundLevel = Math.floor(world.height / 3);
            
            for (let x = 0; x < world.width; x++) {
                let h = groundLevel + Math.floor(noise(x, 0.05) * 8 + noise(x, 0.01) * 20);
                if (h < 5) h = 5;
                if (h > world.height - 5) h = world.height - 5;
                
                // Biomes roughly
                let isDesert = Math.sin(x * 0.03 + seed) > 0.6;

                for (let y = 0; y < world.height; y++) {
                    if (y >= world.height - 2) {
                        world.tiles[x][y] = BLOCKS.BEDROCK;
                    } else if (y > h) {
                        if (y < h + 5) {
                            world.tiles[x][y] = isDesert ? BLOCKS.SAND : BLOCKS.DIRT;
                        } else {
                            world.tiles[x][y] = BLOCKS.STONE;
                            // Ores
                            if (rand() > 0.96) {
                                let r = rand();
                                if (r > 0.9 && y > h + 20) world.tiles[x][y] = BLOCKS.DIAMOND_ORE;
                                else if (r > 0.7 && y > h + 10) world.tiles[x][y] = BLOCKS.GOLD_ORE;
                                else if (r > 0.4) world.tiles[x][y] = BLOCKS.COAL_ORE;
                            }
                        }
                    } else if (y === h) {
                        world.tiles[x][y] = isDesert ? BLOCKS.SAND : BLOCKS.GRASS;
                    }
                }

                // Surface Objects
                if (x > 5 && x < world.width - 5) {
                    if (isDesert && world.tiles[x][h] === BLOCKS.SAND && rand() > 0.95) {
                         // Cactus
                         let ch = 2 + Math.floor(rand() * 2);
                         for(let i=1; i<=ch; i++) world.tiles[x][h-i] = BLOCKS.CACTUS;
                    } else if (!isDesert && world.tiles[x][h] === BLOCKS.GRASS) {
                        if (rand() > 0.9) { // Tree
                            let treeHeight = 3 + Math.floor(rand() * 4);
                            for (let i = 1; i <= treeHeight; i++) {
                                world.tiles[x][h - i] = BLOCKS.WOOD;
                            }
                            for (let lx = x - 1; lx <= x + 1; lx++) {
                                for (let ly = h - treeHeight - 1; ly <= h - treeHeight; ly++) {
                                    if (lx >= 0 && lx < world.width && ly >= 0 && world.tiles[lx][ly] === BLOCKS.AIR) {
                                        world.tiles[lx][ly] = BLOCKS.LEAVES;
                                    }
                                }
                            }
                        } else if (rand() > 0.9) {
                            world.tiles[x][h-1] = BLOCKS.FLOWER;
                        }
                    }
                }
            }
        }

        // --- SAVE / LOAD SYSTEM ---
        function saveWorld() {
            // Include player state in save
            world.player = player;
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(world));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", world.name + ".json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            console.log("World saved as JSON");
        }

        function loadWorldFromFile(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedWorld = JSON.parse(e.target.result);
                    startGame(loadedWorld);
                } catch (err) {
                    alert("Ошибка загрузки мира: " + err);
                }
            };
            reader.readAsText(file);
        }

        // --- GAME LOOP ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (document.getElementById('mods-menu').classList.contains('hidden')) {
                updatePhysics(dt);
            }
            render();

            document.getElementById('fps-counter').innerText = `FPS: ${Math.round(1/dt)}`;
            document.getElementById('coords').innerText = `X: ${Math.round(player.x/TILE_SIZE)} Y: ${Math.round(player.y/TILE_SIZE)}`;

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updatePhysics(dt) {
            // Controls
            let dx = 0;
            let speedMult = mods.speed ? 3 : 1;

            if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
            if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

            // Mobile Joystick
            if (joystick.active) {
                dx = joystick.dx / 25; // Normalize somewhat
                if (dx > 1) dx = 1; if (dx < -1) dx = -1;
            }

            player.vx = dx * player.speed * speedMult * 60 * dt;

            if (mods.fly) {
                // God Mode / Fly: No Gravity, Arrow Keys move freely
                let dy = 0;
                if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
                if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
                
                // Jump btn is up
                if (keys['Space']) dy = -1;

                player.vy = dy * player.speed * speedMult * 60 * dt;
                
                // No gravity
            } else {
                // Gravity
                let gravity = mods.low_gravity ? 10 : 30;
                player.vy += gravity * dt;
                player.vy *= 0.95; 

                // Jump
                if ((keys['Space'] || keys['ArrowUp']) && player.grounded) {
                    let force = mods.mega_jump ? player.jumpForce * 1.8 : player.jumpForce;
                    player.vy = -force;
                    player.grounded = false;
                }
            }

            // Horizontal Movement
            let nextX = player.x + player.vx;
            if (!mods.noclip && checkCollision(nextX, player.y)) {
                player.vx = 0;
            } else {
                player.x = nextX;
            }
            
            // Limit World Bounds X
            if (player.x < 0) player.x = 0;
            if (player.x > world.width * TILE_SIZE - player.width) player.x = world.width * TILE_SIZE - player.width;

            // Vertical Movement
            let nextY = player.y + player.vy;
            player.grounded = false;
            if (!mods.noclip && checkCollision(player.x, nextY)) {
                if (player.vy > 0) player.grounded = true;
                player.vy = 0;
                player.y = Math.floor(player.y); 
            } else {
                player.y = nextY;
            }

            // Death / Void
            if (player.y > world.height * TILE_SIZE) {
                player.y = 0;
                player.vy = 0;
            }

            // Camera follow
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Clamp Camera
            camera.x = Math.max(0, Math.min(camera.x, world.width * TILE_SIZE - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, world.height * TILE_SIZE - canvas.height));
            
            // Dig/Place Logic (Mouse Held)
            if (mouse.leftDown) handleInteraction(true);
            if (mouse.rightDown) handleInteraction(false);
        }

        function checkCollision(x, y) {
            // Check all 4 corners of player rect
            const corners = [
                {x: x, y: y},
                {x: x + player.width, y: y},
                {x: x, y: y + player.height},
                {x: x + player.width, y: y + player.height}
            ];

            for (let p of corners) {
                let tx = Math.floor(p.x / TILE_SIZE);
                let ty = Math.floor(p.y / TILE_SIZE);
                if (tx >= 0 && tx < world.width && ty >= 0 && ty < world.height) {
                    if (world.tiles[tx][ty] !== BLOCKS.AIR) return true;
                }
            }
            return false;
        }

        function handleInteraction(isLeftClick) {
            // Calculate world coordinates of mouse/touch
            let wx = mouse.x + camera.x;
            let wy = mouse.y + camera.y;

            let tx = Math.floor(wx / TILE_SIZE);
            let ty = Math.floor(wy / TILE_SIZE);

            // Range Check
            let pdx = (player.x + player.width/2) - wx;
            let pdy = (player.y + player.height/2) - wy;
            let dist = Math.sqrt(pdx*pdx + pdy*pdy);
            
            let reach = mods.long_reach ? 15 : 5;
            if (dist > reach * TILE_SIZE) return;

            if (tx >= 0 && tx < world.width && ty >= 0 && ty < world.height) {
                if (isLeftClick) {
                    // Mine
                    if (world.tiles[tx][ty] !== BLOCKS.AIR && world.tiles[tx][ty] !== BLOCKS.BEDROCK) {
                        let blockType = world.tiles[tx][ty];
                        world.tiles[tx][ty] = BLOCKS.AIR;
                        // Add to inventory
                        addToInventory(blockType, 1);
                    }
                } else {
                    // Place
                    if (world.tiles[tx][ty] === BLOCKS.AIR) {
                        // Check if player is not in the way
                        let pRect = { l: player.x, r: player.x + player.width, t: player.y, b: player.y + player.height };
                        let bRect = { l: tx*TILE_SIZE, r: (tx+1)*TILE_SIZE, t: ty*TILE_SIZE, b: (ty+1)*TILE_SIZE };
                        
                        if (!(pRect.r <= bRect.l || pRect.l >= bRect.r || pRect.b <= bRect.t || pRect.t >= bRect.b)) {
                            // Collision with player, don't place
                            return;
                        }

                        let slot = player.inventory[player.selectedSlot];
                        if (slot.count > 0 && slot.id !== BLOCKS.AIR) {
                            world.tiles[tx][ty] = slot.id;
                            // In Adventure Mode, don't consume blocks
                            if (world.mode !== 'Adventure') {
                                slot.count--;
                            }
                            updateHotbarUI();
                        }
                    }
                }
            }
        }

        function addToInventory(id, amount) {
            // Check current slots
            let found = false;
            for(let slot of player.inventory) {
                if (slot.id === id) {
                    slot.count += amount;
                    found = true;
                    break;
                }
            }
            // If not found, try to find empty or just ignore for MVP simple inventory
            if (!found) {
                for(let slot of player.inventory) {
                    if (slot.count === 0) {
                        slot.id = id;
                        slot.count = amount;
                        break;
                    }
                }
            }
            updateHotbarUI();
        }

        // --- RENDER ---
        function render() {
            // Clear
            ctx.fillStyle = '#87CEEB'; // Sky Color
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Visible Range
            let startCol = Math.floor(camera.x / TILE_SIZE);
            let endCol = startCol + (canvas.width / TILE_SIZE) + 1;
            let startRow = Math.floor(camera.y / TILE_SIZE);
            let endRow = startRow + (canvas.height / TILE_SIZE) + 1;

            // Draw Tiles
            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    if (c >= 0 && c < world.width && r >= 0 && r < world.height) {
                        let tile = world.tiles[c][r];
                        if (tile !== BLOCKS.AIR) {
                            ctx.fillStyle = BLOCK_COLORS[tile] || '#FF00FF';
                            ctx.fillRect(
                                Math.floor(c * TILE_SIZE - camera.x),
                                Math.floor(r * TILE_SIZE - camera.y),
                                TILE_SIZE, TILE_SIZE
                            );
                            // Simple border for blocks
                            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                            ctx.strokeRect(
                                Math.floor(c * TILE_SIZE - camera.x),
                                Math.floor(r * TILE_SIZE - camera.y),
                                TILE_SIZE, TILE_SIZE
                            );
                        }
                    }
                }
            }

            // Draw Player
            ctx.fillStyle = '#FF0000'; // Player Color
            ctx.fillRect(
                Math.floor(player.x - camera.x),
                Math.floor(player.y - camera.y),
                player.width, player.height
            );
            
            // Draw Highlight (Mouse cursor block)
            let mx = Math.floor((mouse.x + camera.x) / TILE_SIZE) * TILE_SIZE - camera.x;
            let my = Math.floor((mouse.y + camera.y) / TILE_SIZE) * TILE_SIZE - camera.y;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(mx, my, TILE_SIZE, TILE_SIZE);
        }

        // --- UI & INPUT HELPERS ---
        function toggleMap() {
            const mapContainer = document.getElementById('minimap-container');
            const isHidden = mapContainer.style.display === 'none' || mapContainer.style.display === '';
            mapContainer.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                updateMinimap();
            }
        }

        function updateMinimap() {
            const mCanvas = document.getElementById('minimap-canvas');
            const mCtx = mCanvas.getContext('2d');
            
            // Draw all tiles (simple)
            mCtx.fillStyle = '#87CEEB';
            mCtx.fillRect(0,0,mCanvas.width, mCanvas.height);
            
            for(let x=0; x<world.width; x++) {
                for(let y=0; y<world.height; y++) {
                    let tile = world.tiles[x][y];
                    if (tile !== BLOCKS.AIR) {
                        mCtx.fillStyle = BLOCK_COLORS[tile] || '#000';
                        mCtx.fillRect(x, y, 1, 1);
                    }
                }
            }
            // Draw player
            let px = Math.floor(player.x / TILE_SIZE);
            let py = Math.floor(player.y / TILE_SIZE);
            mCtx.fillStyle = 'red';
            mCtx.fillRect(px-1, py-1, 3, 3);
            
            if (document.getElementById('minimap-container').style.display !== 'none') {
                 requestAnimationFrame(updateMinimap);
            }
        }

        function toggleInventory() {
            const modal = document.getElementById('inventory-modal');
            const isHidden = modal.style.display === 'none' || modal.style.display === '';
            modal.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) {
                currentInvPage = 0;
                updateInventoryGrid();
            }
        }

        function changeInvPage(dir) {
            let maxPages = Math.ceil(INVENTORY_SIZE / INV_PAGE_SIZE);
            currentInvPage += dir;
            if (currentInvPage < 0) currentInvPage = 0;
            if (currentInvPage >= maxPages) currentInvPage = maxPages - 1;
            updateInventoryGrid();
        }

        function updateInventoryGrid() {
            const container = document.getElementById('full-inventory');
            container.innerHTML = '';
            
            let start = currentInvPage * INV_PAGE_SIZE;
            let end = Math.min(start + INV_PAGE_SIZE, INVENTORY_SIZE);
            
            let maxPages = Math.ceil(INVENTORY_SIZE / INV_PAGE_SIZE);
            document.getElementById('page-indicator').innerText = `${currentInvPage + 1} / ${maxPages}`;

            for (let i = start; i < end; i++) {
                let slot = player.inventory[i];
                let div = document.createElement('div');
                div.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
                div.onclick = () => {
                    // Logic: Swap clicked slot with selected hotbar slot
                    // The hotbar is slot 0-7 (technically)
                    // If we click a slot in the inventory, we swap it with the CURRENTLY SELECTED hotbar slot
                    
                    if (i !== player.selectedSlot) {
                        let temp = player.inventory[player.selectedSlot];
                        player.inventory[player.selectedSlot] = player.inventory[i];
                        player.inventory[i] = temp;
                        
                        updateHotbarUI();
                        updateInventoryGrid();
                    }
                };

                if (slot.count > 0 && slot.id !== BLOCKS.AIR) {
                    let color = BLOCK_COLORS[slot.id];
                    let preview = document.createElement('div');
                    preview.style.backgroundColor = color;
                    preview.style.width = '24px';
                    preview.style.height = '24px';
                    div.appendChild(preview);

                    let count = document.createElement('span');
                    count.className = 'inv-count';
                    count.innerText = slot.count;
                    div.appendChild(count);
                }
                container.appendChild(div);
            }
        }

        function updateHotbarUI() {
            const container = document.getElementById('hotbar');
            container.innerHTML = '';
            
            // Only show first HOTBAR_SIZE slots
            for (let i = 0; i < HOTBAR_SIZE; i++) {
                let slot = player.inventory[i];
                let div = document.createElement('div');
                div.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
                div.onclick = () => {
                    player.selectedSlot = i;
                    updateHotbarUI();
                };
                
                if (slot.count > 0 && slot.id !== BLOCKS.AIR) {
                    let color = BLOCK_COLORS[slot.id];
                    let preview = document.createElement('div');
                    preview.style.backgroundColor = color;
                    preview.style.width = '20px';
                    preview.style.height = '20px';
                    div.appendChild(preview);

                    let count = document.createElement('span');
                    count.className = 'inv-count';
                    count.innerText = slot.count;
                    div.appendChild(count);
                }
                container.appendChild(div);
            }
        }

        function setupInputs() {
            // Keyboard
            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.key >= '1' && e.key <= '8') {
                    player.selectedSlot = parseInt(e.key) - 1;
                    updateHotbarUI();
                }
                if (e.code === 'KeyE') {
                    toggleInventory();
                }
                if (e.code === 'KeyM') {
                    toggleMap();
                }
                if (e.code === 'KeyC') {
                    if (document.getElementById('mods-menu').classList.contains('hidden')) {
                        openModsMenu();
                    } else {
                        closeModsMenu();
                    }
                }
            });
            window.addEventListener('keyup', e => keys[e.code] = false);

            // Mouse
            canvas.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            canvas.addEventListener('mousedown', e => {
                if (!document.getElementById('mods-menu').classList.contains('hidden')) return;
                if (e.button === 0) mouse.leftDown = true;
                if (e.button === 2) mouse.rightDown = true;
            });
            window.addEventListener('mouseup', () => {
                mouse.leftDown = false;
                mouse.rightDown = false;
            });
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Mobile Controls
            const joystickZone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            
            // Prevent interaction if mods menu is open
            const isModsOpen = () => !document.getElementById('mods-menu').classList.contains('hidden');

            joystickZone.addEventListener('touchstart', e => {
                if (isModsOpen()) return;
                e.preventDefault();
                let touch = e.changedTouches[0];
                joystick.active = true;
                joystick.pointerId = touch.identifier;
                // Get center of zone
                let rect = joystickZone.getBoundingClientRect();
                joystick.originX = rect.left + rect.width / 2;
                joystick.originY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            joystickZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystick.pointerId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            }, {passive: false});

            const endJoystick = (e) => {
                 for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystick.pointerId) {
                        joystick.active = false;
                        joystick.dx = 0; joystick.dy = 0;
                        knob.style.transform = `translate(-50%, -50%)`;
                        break;
                    }
                }
            };

            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            function updateJoystick(cx, cy) {
                let dx = cx - joystick.originX;
                let dy = cy - joystick.originY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let maxDist = 25; // Radius
                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }
                joystick.dx = dx;
                joystick.dy = dy;
                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            // Jump Button
            const btnJump = document.getElementById('btn-jump');
            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; }, {passive: false});
            btnJump.addEventListener('touchend', (e) => { e.preventDefault(); keys['Space'] = false; }, {passive: false});

            // Action/Dig Button (Simulate Left Click at player location + offset or simple auto-mine ahead?)
            // For MVP mobile: Tap screen to mine/place is better.
            // Let's rely on touching the canvas for mining on mobile.
            
            // Canvas Touch for mining
            canvas.addEventListener('touchstart', e => {
                if (!document.getElementById('mods-menu').classList.contains('hidden')) return;
                if (e.target === canvas) {
                    let t = e.changedTouches[0];
                    mouse.x = t.clientX;
                    mouse.y = t.clientY;
                    if (mobileActionMode === 'MINE') {
                        mouse.leftDown = true;
                    } else {
                        mouse.rightDown = true;
                    }
                }
            }, {passive: false});
            
            canvas.addEventListener('touchmove', e => {
                if (e.target === canvas) {
                    e.preventDefault();
                    let t = e.changedTouches[0];
                    mouse.x = t.clientX;
                    mouse.y = t.clientY;
                }
            }, {passive: false});

            canvas.addEventListener('touchend', e => {
                if (e.target === canvas) {
                    mouse.leftDown = false;
                    mouse.rightDown = false;
                }
            });
        }

    </script>
</body>
</html>